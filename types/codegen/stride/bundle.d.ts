import * as _93 from "./airdrop/airdrop";
import * as _94 from "./airdrop/genesis";
import * as _95 from "./airdrop/query";
import * as _96 from "./airdrop/tx";
import * as _97 from "./autopilot/genesis";
import * as _98 from "./autopilot/params";
import * as _99 from "./autopilot/query";
import * as _100 from "./claim/claim";
import * as _101 from "./claim/genesis";
import * as _102 from "./claim/params";
import * as _103 from "./claim/query";
import * as _104 from "./claim/tx";
import * as _105 from "./epochs/genesis";
import * as _106 from "./epochs/query";
import * as _107 from "./icacallbacks/callback_data";
import * as _108 from "./icacallbacks/genesis";
import * as _109 from "./icacallbacks/packet";
import * as _110 from "./icacallbacks/params";
import * as _111 from "./icacallbacks/query";
import * as _113 from "./icaoracle/callbacks";
import * as _114 from "./icaoracle/contract";
import * as _115 from "./icaoracle/genesis";
import * as _116 from "./icaoracle/icaoracle";
import * as _117 from "./icaoracle/query";
import * as _118 from "./icaoracle/tx";
import * as _119 from "./interchainquery/v1/genesis";
import * as _120 from "./interchainquery/v1/messages";
import * as _121 from "./interchainquery/v1/query";
import * as _122 from "./mint/v1beta1/genesis";
import * as _123 from "./mint/v1beta1/mint";
import * as _124 from "./mint/v1beta1/query";
import * as _125 from "./records/callbacks";
import * as _126 from "./records/genesis";
import * as _127 from "./records/params";
import * as _128 from "./records/query";
import * as _129 from "./records/records";
import * as _130 from "./stakedym/genesis";
import * as _131 from "./stakedym/query";
import * as _132 from "./stakedym/stakedym";
import * as _133 from "./stakedym/tx";
import * as _134 from "./stakeibc/address_unbonding";
import * as _135 from "./stakeibc/callbacks";
import * as _136 from "./stakeibc/epoch_tracker";
import * as _137 from "./stakeibc/genesis";
import * as _138 from "./stakeibc/gov";
import * as _139 from "./stakeibc/host_zone";
import * as _140 from "./stakeibc/ica_account";
import * as _141 from "./stakeibc/packet";
import * as _142 from "./stakeibc/params";
import * as _143 from "./stakeibc/query";
import * as _144 from "./stakeibc/trade_route";
import * as _145 from "./stakeibc/tx";
import * as _146 from "./stakeibc/validator";
import * as _147 from "./staketia/genesis";
import * as _148 from "./staketia/query";
import * as _149 from "./staketia/staketia";
import * as _150 from "./staketia/tx";
import * as _152 from "./vesting/vesting";
import * as _240 from "./airdrop/query.lcd";
import * as _241 from "./autopilot/query.lcd";
import * as _242 from "./claim/query.lcd";
import * as _243 from "./epochs/query.lcd";
import * as _244 from "./icacallbacks/query.lcd";
import * as _245 from "./icaoracle/query.lcd";
import * as _246 from "./mint/v1beta1/query.lcd";
import * as _247 from "./records/query.lcd";
import * as _248 from "./stakedym/query.lcd";
import * as _249 from "./stakeibc/query.lcd";
import * as _250 from "./staketia/query.lcd";
import * as _251 from "./airdrop/query.rpc.query";
import * as _252 from "./autopilot/query.rpc.query";
import * as _253 from "./claim/query.rpc.query";
import * as _254 from "./epochs/query.rpc.query";
import * as _255 from "./icacallbacks/query.rpc.query";
import * as _256 from "./icaoracle/query.rpc.query";
import * as _257 from "./mint/v1beta1/query.rpc.query";
import * as _258 from "./records/query.rpc.query";
import * as _259 from "./stakedym/query.rpc.query";
import * as _260 from "./stakeibc/query.rpc.query";
import * as _261 from "./staketia/query.rpc.query";
import * as _262 from "./airdrop/tx.rpc.msg";
import * as _263 from "./claim/tx.rpc.msg";
import * as _264 from "./icaoracle/tx.rpc.msg";
import * as _265 from "./interchainquery/v1/messages.rpc.msg";
import * as _266 from "./stakedym/tx.rpc.msg";
import * as _267 from "./stakeibc/tx.rpc.msg";
import * as _268 from "./staketia/tx.rpc.msg";
export declare namespace stride {
    const airdrop: {
        MsgClientImpl: typeof _262.MsgClientImpl;
        QueryClientImpl: typeof _251.QueryClientImpl;
        createRpcQueryExtension: (base: import("@cosmjs/stargate").QueryClient) => {
            airdrop(request: _95.QueryAirdropRequest): Promise<_95.QueryAirdropResponse>;
            allAirdrops(request?: _95.QueryAllAirdropsRequest): Promise<_95.QueryAllAirdropsResponse>;
            userAllocation(request: _95.QueryUserAllocationRequest): Promise<_95.QueryUserAllocationResponse>;
            userAllocations(request: _95.QueryUserAllocationsRequest): Promise<_95.QueryUserAllocationsResponse>;
            allAllocations(request: _95.QueryAllAllocationsRequest): Promise<_95.QueryAllAllocationsResponse>;
            userSummary(request: _95.QueryUserSummaryRequest): Promise<_95.QueryUserSummaryResponse>;
        };
        LCDQueryClient: typeof _240.LCDQueryClient;
        registry: readonly [string, import("@cosmjs/proto-signing").GeneratedType][];
        load: (protoRegistry: import("@cosmjs/proto-signing").Registry) => void;
        MessageComposer: {
            encoded: {
                claimDaily(value: _96.MsgClaimDaily): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                claimEarly(value: _96.MsgClaimEarly): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                createAirdrop(value: _96.MsgCreateAirdrop): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                updateAirdrop(value: _96.MsgUpdateAirdrop): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                addAllocations(value: _96.MsgAddAllocations): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                updateUserAllocation(value: _96.MsgUpdateUserAllocation): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                linkAddresses(value: _96.MsgLinkAddresses): {
                    typeUrl: string;
                    value: Uint8Array;
                };
            };
            withTypeUrl: {
                claimDaily(value: _96.MsgClaimDaily): {
                    typeUrl: string;
                    value: _96.MsgClaimDaily;
                };
                claimEarly(value: _96.MsgClaimEarly): {
                    typeUrl: string;
                    value: _96.MsgClaimEarly;
                };
                createAirdrop(value: _96.MsgCreateAirdrop): {
                    typeUrl: string;
                    value: _96.MsgCreateAirdrop;
                };
                updateAirdrop(value: _96.MsgUpdateAirdrop): {
                    typeUrl: string;
                    value: _96.MsgUpdateAirdrop;
                };
                addAllocations(value: _96.MsgAddAllocations): {
                    typeUrl: string;
                    value: _96.MsgAddAllocations;
                };
                updateUserAllocation(value: _96.MsgUpdateUserAllocation): {
                    typeUrl: string;
                    value: _96.MsgUpdateUserAllocation;
                };
                linkAddresses(value: _96.MsgLinkAddresses): {
                    typeUrl: string;
                    value: _96.MsgLinkAddresses;
                };
            };
            fromPartial: {
                claimDaily(value: _96.MsgClaimDaily): {
                    typeUrl: string;
                    value: _96.MsgClaimDaily;
                };
                claimEarly(value: _96.MsgClaimEarly): {
                    typeUrl: string;
                    value: _96.MsgClaimEarly;
                };
                createAirdrop(value: _96.MsgCreateAirdrop): {
                    typeUrl: string;
                    value: _96.MsgCreateAirdrop;
                };
                updateAirdrop(value: _96.MsgUpdateAirdrop): {
                    typeUrl: string;
                    value: _96.MsgUpdateAirdrop;
                };
                addAllocations(value: _96.MsgAddAllocations): {
                    typeUrl: string;
                    value: _96.MsgAddAllocations;
                };
                updateUserAllocation(value: _96.MsgUpdateUserAllocation): {
                    typeUrl: string;
                    value: _96.MsgUpdateUserAllocation;
                };
                linkAddresses(value: _96.MsgLinkAddresses): {
                    typeUrl: string;
                    value: _96.MsgLinkAddresses;
                };
            };
        };
        AminoConverter: {
            "/stride.airdrop.MsgClaimDaily": {
                aminoType: string;
                toAmino: ({ claimer, airdropId }: _96.MsgClaimDaily) => {
                    claimer: string;
                    airdrop_id: string;
                };
                fromAmino: ({ claimer, airdrop_id }: {
                    claimer: string;
                    airdrop_id: string;
                }) => _96.MsgClaimDaily;
            };
            "/stride.airdrop.MsgClaimEarly": {
                aminoType: string;
                toAmino: ({ claimer, airdropId }: _96.MsgClaimEarly) => {
                    claimer: string;
                    airdrop_id: string;
                };
                fromAmino: ({ claimer, airdrop_id }: {
                    claimer: string;
                    airdrop_id: string;
                }) => _96.MsgClaimEarly;
            };
            "/stride.airdrop.MsgCreateAirdrop": {
                aminoType: string;
                toAmino: ({ admin, airdropId, rewardDenom, distributionStartDate, distributionEndDate, clawbackDate, claimTypeDeadlineDate, earlyClaimPenalty, distributorAddress, allocatorAddress, linkerAddress }: _96.MsgCreateAirdrop) => {
                    admin: string;
                    airdrop_id: string;
                    reward_denom: string;
                    distribution_start_date: {
                        seconds: string;
                        nanos: number;
                    };
                    distribution_end_date: {
                        seconds: string;
                        nanos: number;
                    };
                    clawback_date: {
                        seconds: string;
                        nanos: number;
                    };
                    claim_type_deadline_date: {
                        seconds: string;
                        nanos: number;
                    };
                    early_claim_penalty: string;
                    distributor_address: string;
                    allocator_address: string;
                    linker_address: string;
                };
                fromAmino: ({ admin, airdrop_id, reward_denom, distribution_start_date, distribution_end_date, clawback_date, claim_type_deadline_date, early_claim_penalty, distributor_address, allocator_address, linker_address }: {
                    admin: string;
                    airdrop_id: string;
                    reward_denom: string;
                    distribution_start_date: {
                        seconds: string;
                        nanos: number;
                    };
                    distribution_end_date: {
                        seconds: string;
                        nanos: number;
                    };
                    clawback_date: {
                        seconds: string;
                        nanos: number;
                    };
                    claim_type_deadline_date: {
                        seconds: string;
                        nanos: number;
                    };
                    early_claim_penalty: string;
                    distributor_address: string;
                    allocator_address: string;
                    linker_address: string;
                }) => _96.MsgCreateAirdrop;
            };
            "/stride.airdrop.MsgUpdateAirdrop": {
                aminoType: string;
                toAmino: ({ admin, airdropId, rewardDenom, distributionStartDate, distributionEndDate, clawbackDate, claimTypeDeadlineDate, earlyClaimPenalty, distributorAddress, allocatorAddress, linkerAddress }: _96.MsgUpdateAirdrop) => {
                    admin: string;
                    airdrop_id: string;
                    reward_denom: string;
                    distribution_start_date: {
                        seconds: string;
                        nanos: number;
                    };
                    distribution_end_date: {
                        seconds: string;
                        nanos: number;
                    };
                    clawback_date: {
                        seconds: string;
                        nanos: number;
                    };
                    claim_type_deadline_date: {
                        seconds: string;
                        nanos: number;
                    };
                    early_claim_penalty: string;
                    distributor_address: string;
                    allocator_address: string;
                    linker_address: string;
                };
                fromAmino: ({ admin, airdrop_id, reward_denom, distribution_start_date, distribution_end_date, clawback_date, claim_type_deadline_date, early_claim_penalty, distributor_address, allocator_address, linker_address }: {
                    admin: string;
                    airdrop_id: string;
                    reward_denom: string;
                    distribution_start_date: {
                        seconds: string;
                        nanos: number;
                    };
                    distribution_end_date: {
                        seconds: string;
                        nanos: number;
                    };
                    clawback_date: {
                        seconds: string;
                        nanos: number;
                    };
                    claim_type_deadline_date: {
                        seconds: string;
                        nanos: number;
                    };
                    early_claim_penalty: string;
                    distributor_address: string;
                    allocator_address: string;
                    linker_address: string;
                }) => _96.MsgUpdateAirdrop;
            };
            "/stride.airdrop.MsgAddAllocations": {
                aminoType: string;
                toAmino: ({ admin, airdropId, allocations }: _96.MsgAddAllocations) => {
                    admin: string;
                    airdrop_id: string;
                    allocations: {
                        user_address: string;
                        allocations: string[];
                    }[];
                };
                fromAmino: ({ admin, airdrop_id, allocations }: {
                    admin: string;
                    airdrop_id: string;
                    allocations: {
                        user_address: string;
                        allocations: string[];
                    }[];
                }) => _96.MsgAddAllocations;
            };
            "/stride.airdrop.MsgUpdateUserAllocation": {
                aminoType: string;
                toAmino: ({ admin, airdropId, userAddress, allocations }: _96.MsgUpdateUserAllocation) => {
                    admin: string;
                    airdrop_id: string;
                    user_address: string;
                    allocations: string[];
                };
                fromAmino: ({ admin, airdrop_id, user_address, allocations }: {
                    admin: string;
                    airdrop_id: string;
                    user_address: string;
                    allocations: string[];
                }) => _96.MsgUpdateUserAllocation;
            };
            "/stride.airdrop.MsgLinkAddresses": {
                aminoType: string;
                toAmino: ({ admin, airdropId, strideAddress, hostAddress }: _96.MsgLinkAddresses) => {
                    admin: string;
                    airdrop_id: string;
                    stride_address: string;
                    host_address: string;
                };
                fromAmino: ({ admin, airdrop_id, stride_address, host_address }: {
                    admin: string;
                    airdrop_id: string;
                    stride_address: string;
                    host_address: string;
                }) => _96.MsgLinkAddresses;
            };
        };
        MsgClaimDaily: {
            encode(message: _96.MsgClaimDaily, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _96.MsgClaimDaily;
            fromPartial(object: {
                claimer?: string;
                airdropId?: string;
            }): _96.MsgClaimDaily;
        };
        MsgClaimDailyResponse: {
            encode(_: _96.MsgClaimDailyResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _96.MsgClaimDailyResponse;
            fromPartial(_: {}): _96.MsgClaimDailyResponse;
        };
        MsgClaimEarly: {
            encode(message: _96.MsgClaimEarly, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _96.MsgClaimEarly;
            fromPartial(object: {
                claimer?: string;
                airdropId?: string;
            }): _96.MsgClaimEarly;
        };
        MsgClaimEarlyResponse: {
            encode(_: _96.MsgClaimEarlyResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _96.MsgClaimEarlyResponse;
            fromPartial(_: {}): _96.MsgClaimEarlyResponse;
        };
        MsgCreateAirdrop: {
            encode(message: _96.MsgCreateAirdrop, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _96.MsgCreateAirdrop;
            fromPartial(object: {
                admin?: string;
                airdropId?: string;
                rewardDenom?: string;
                distributionStartDate?: Date;
                distributionEndDate?: Date;
                clawbackDate?: Date;
                claimTypeDeadlineDate?: Date;
                earlyClaimPenalty?: string;
                distributorAddress?: string;
                allocatorAddress?: string;
                linkerAddress?: string;
            }): _96.MsgCreateAirdrop;
        };
        MsgCreateAirdropResponse: {
            encode(_: _96.MsgCreateAirdropResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _96.MsgCreateAirdropResponse;
            fromPartial(_: {}): _96.MsgCreateAirdropResponse;
        };
        MsgUpdateAirdrop: {
            encode(message: _96.MsgUpdateAirdrop, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _96.MsgUpdateAirdrop;
            fromPartial(object: {
                admin?: string;
                airdropId?: string;
                rewardDenom?: string;
                distributionStartDate?: Date;
                distributionEndDate?: Date;
                clawbackDate?: Date;
                claimTypeDeadlineDate?: Date;
                earlyClaimPenalty?: string;
                distributorAddress?: string;
                allocatorAddress?: string;
                linkerAddress?: string;
            }): _96.MsgUpdateAirdrop;
        };
        MsgUpdateAirdropResponse: {
            encode(_: _96.MsgUpdateAirdropResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _96.MsgUpdateAirdropResponse;
            fromPartial(_: {}): _96.MsgUpdateAirdropResponse;
        };
        RawAllocation: {
            encode(message: _96.RawAllocation, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _96.RawAllocation;
            fromPartial(object: {
                userAddress?: string;
                allocations?: string[];
            }): _96.RawAllocation;
        };
        MsgAddAllocations: {
            encode(message: _96.MsgAddAllocations, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _96.MsgAddAllocations;
            fromPartial(object: {
                admin?: string;
                airdropId?: string;
                allocations?: {
                    userAddress?: string;
                    allocations?: string[];
                }[];
            }): _96.MsgAddAllocations;
        };
        MsgAddAllocationsResponse: {
            encode(_: _96.MsgAddAllocationsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _96.MsgAddAllocationsResponse;
            fromPartial(_: {}): _96.MsgAddAllocationsResponse;
        };
        MsgUpdateUserAllocation: {
            encode(message: _96.MsgUpdateUserAllocation, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _96.MsgUpdateUserAllocation;
            fromPartial(object: {
                admin?: string;
                airdropId?: string;
                userAddress?: string;
                allocations?: string[];
            }): _96.MsgUpdateUserAllocation;
        };
        MsgUpdateUserAllocationResponse: {
            encode(_: _96.MsgUpdateUserAllocationResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _96.MsgUpdateUserAllocationResponse;
            fromPartial(_: {}): _96.MsgUpdateUserAllocationResponse;
        };
        MsgLinkAddresses: {
            encode(message: _96.MsgLinkAddresses, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _96.MsgLinkAddresses;
            fromPartial(object: {
                admin?: string;
                airdropId?: string;
                strideAddress?: string;
                hostAddress?: string;
            }): _96.MsgLinkAddresses;
        };
        MsgLinkAddressesResponse: {
            encode(_: _96.MsgLinkAddressesResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _96.MsgLinkAddressesResponse;
            fromPartial(_: {}): _96.MsgLinkAddressesResponse;
        };
        QueryAirdropRequest: {
            encode(message: _95.QueryAirdropRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _95.QueryAirdropRequest;
            fromPartial(object: {
                id?: string;
            }): _95.QueryAirdropRequest;
        };
        QueryAirdropResponse: {
            encode(message: _95.QueryAirdropResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _95.QueryAirdropResponse;
            fromPartial(object: {
                airdrop?: {
                    id?: string;
                    rewardDenom?: string;
                    distributionStartDate?: Date;
                    distributionEndDate?: Date;
                    clawbackDate?: Date;
                    claimTypeDeadlineDate?: Date;
                    earlyClaimPenalty?: string;
                    distributorAddress?: string;
                    allocatorAddress?: string;
                    linkerAddress?: string;
                };
            }): _95.QueryAirdropResponse;
        };
        QueryAllAirdropsRequest: {
            encode(_: _95.QueryAllAirdropsRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _95.QueryAllAirdropsRequest;
            fromPartial(_: {}): _95.QueryAllAirdropsRequest;
        };
        QueryAllAirdropsResponse: {
            encode(message: _95.QueryAllAirdropsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _95.QueryAllAirdropsResponse;
            fromPartial(object: {
                airdrops?: {
                    id?: string;
                    rewardDenom?: string;
                    distributionStartDate?: Date;
                    distributionEndDate?: Date;
                    clawbackDate?: Date;
                    claimTypeDeadlineDate?: Date;
                    earlyClaimPenalty?: string;
                    distributorAddress?: string;
                    allocatorAddress?: string;
                    linkerAddress?: string;
                }[];
            }): _95.QueryAllAirdropsResponse;
        };
        QueryUserAllocationRequest: {
            encode(message: _95.QueryUserAllocationRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _95.QueryUserAllocationRequest;
            fromPartial(object: {
                airdropId?: string;
                address?: string;
            }): _95.QueryUserAllocationRequest;
        };
        QueryUserAllocationResponse: {
            encode(message: _95.QueryUserAllocationResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _95.QueryUserAllocationResponse;
            fromPartial(object: {
                userAllocation?: {
                    airdropId?: string;
                    address?: string;
                    claimed?: string;
                    forfeited?: string;
                    allocations?: string[];
                };
            }): _95.QueryUserAllocationResponse;
        };
        QueryUserAllocationsRequest: {
            encode(message: _95.QueryUserAllocationsRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _95.QueryUserAllocationsRequest;
            fromPartial(object: {
                address?: string;
            }): _95.QueryUserAllocationsRequest;
        };
        QueryUserAllocationsResponse: {
            encode(message: _95.QueryUserAllocationsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _95.QueryUserAllocationsResponse;
            fromPartial(object: {
                userAllocations?: {
                    airdropId?: string;
                    address?: string;
                    claimed?: string;
                    forfeited?: string;
                    allocations?: string[];
                }[];
            }): _95.QueryUserAllocationsResponse;
        };
        QueryAllAllocationsRequest: {
            encode(message: _95.QueryAllAllocationsRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _95.QueryAllAllocationsRequest;
            fromPartial(object: {
                airdropId?: string;
                pagination?: {
                    key?: Uint8Array;
                    offset?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    limit?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    countTotal?: boolean;
                    reverse?: boolean;
                };
            }): _95.QueryAllAllocationsRequest;
        };
        QueryAllAllocationsResponse: {
            encode(message: _95.QueryAllAllocationsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _95.QueryAllAllocationsResponse;
            fromPartial(object: {
                allocations?: {
                    airdropId?: string;
                    address?: string;
                    claimed?: string;
                    forfeited?: string;
                    allocations?: string[];
                }[];
                pagination?: {
                    nextKey?: Uint8Array;
                    total?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                };
            }): _95.QueryAllAllocationsResponse;
        };
        QueryUserSummaryRequest: {
            encode(message: _95.QueryUserSummaryRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _95.QueryUserSummaryRequest;
            fromPartial(object: {
                airdropId?: string;
                address?: string;
            }): _95.QueryUserSummaryRequest;
        };
        QueryUserSummaryResponse: {
            encode(message: _95.QueryUserSummaryResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _95.QueryUserSummaryResponse;
            fromPartial(object: {
                claimType?: string;
                claimed?: string;
                forfeited?: string;
                remaining?: string;
                claimable?: string;
                currentDateIndex?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
            }): _95.QueryUserSummaryResponse;
        };
        GenesisState: {
            encode(message: _94.GenesisState, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _94.GenesisState;
            fromPartial(object: {
                params?: {
                    periodLengthSeconds?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                };
                airdrops?: {
                    id?: string;
                    rewardDenom?: string;
                    distributionStartDate?: Date;
                    distributionEndDate?: Date;
                    clawbackDate?: Date;
                    claimTypeDeadlineDate?: Date;
                    earlyClaimPenalty?: string;
                    distributorAddress?: string;
                    allocatorAddress?: string;
                    linkerAddress?: string;
                }[];
                userAllocations?: {
                    airdropId?: string;
                    address?: string;
                    claimed?: string;
                    forfeited?: string;
                    allocations?: string[];
                }[];
            }): _94.GenesisState;
        };
        claimTypeFromJSON(object: any): _93.ClaimType;
        claimTypeToJSON(object: _93.ClaimType): string;
        ClaimType: typeof _93.ClaimType;
        ClaimTypeSDKType: typeof _93.ClaimTypeSDKType;
        Params: {
            encode(message: _93.Params, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _93.Params;
            fromPartial(object: {
                periodLengthSeconds?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
            }): _93.Params;
        };
        UserAllocation: {
            encode(message: _93.UserAllocation, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _93.UserAllocation;
            fromPartial(object: {
                airdropId?: string;
                address?: string;
                claimed?: string;
                forfeited?: string;
                allocations?: string[];
            }): _93.UserAllocation;
        };
        Airdrop: {
            encode(message: _93.Airdrop, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _93.Airdrop;
            fromPartial(object: {
                id?: string;
                rewardDenom?: string;
                distributionStartDate?: Date;
                distributionEndDate?: Date;
                clawbackDate?: Date;
                claimTypeDeadlineDate?: Date;
                earlyClaimPenalty?: string;
                distributorAddress?: string;
                allocatorAddress?: string;
                linkerAddress?: string;
            }): _93.Airdrop;
        };
    };
    const autopilot: {
        QueryClientImpl: typeof _252.QueryClientImpl;
        createRpcQueryExtension: (base: import("@cosmjs/stargate").QueryClient) => {
            params(request?: _99.QueryParamsRequest): Promise<_99.QueryParamsResponse>;
        };
        LCDQueryClient: typeof _241.LCDQueryClient;
        QueryParamsRequest: {
            encode(_: _99.QueryParamsRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _99.QueryParamsRequest;
            fromPartial(_: {}): _99.QueryParamsRequest;
        };
        QueryParamsResponse: {
            encode(message: _99.QueryParamsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _99.QueryParamsResponse;
            fromPartial(object: {
                params?: {
                    stakeibcActive?: boolean;
                    claimActive?: boolean;
                };
            }): _99.QueryParamsResponse;
        };
        Params: {
            encode(message: _98.Params, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _98.Params;
            fromPartial(object: {
                stakeibcActive?: boolean;
                claimActive?: boolean;
            }): _98.Params;
        };
        GenesisState: {
            encode(message: _97.GenesisState, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _97.GenesisState;
            fromPartial(object: {
                params?: {
                    stakeibcActive?: boolean;
                    claimActive?: boolean;
                };
            }): _97.GenesisState;
        };
    };
    const claim: {
        MsgClientImpl: typeof _263.MsgClientImpl;
        QueryClientImpl: typeof _253.QueryClientImpl;
        createRpcQueryExtension: (base: import("@cosmjs/stargate").QueryClient) => {
            distributorAccountBalance(request: _103.QueryDistributorAccountBalanceRequest): Promise<_103.QueryDistributorAccountBalanceResponse>;
            params(request?: _103.QueryParamsRequest): Promise<_103.QueryParamsResponse>;
            claimRecord(request: _103.QueryClaimRecordRequest): Promise<_103.QueryClaimRecordResponse>;
            claimableForAction(request: _103.QueryClaimableForActionRequest): Promise<_103.QueryClaimableForActionResponse>;
            totalClaimable(request: _103.QueryTotalClaimableRequest): Promise<_103.QueryTotalClaimableResponse>;
            userVestings(request: _103.QueryUserVestingsRequest): Promise<_103.QueryUserVestingsResponse>;
            claimStatus(request: _103.QueryClaimStatusRequest): Promise<_103.QueryClaimStatusResponse>;
            claimMetadata(request?: _103.QueryClaimMetadataRequest): Promise<_103.QueryClaimMetadataResponse>;
        };
        LCDQueryClient: typeof _242.LCDQueryClient;
        registry: readonly [string, import("@cosmjs/proto-signing").GeneratedType][];
        load: (protoRegistry: import("@cosmjs/proto-signing").Registry) => void;
        MessageComposer: {
            encoded: {
                setAirdropAllocations(value: _104.MsgSetAirdropAllocations): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                claimFreeAmount(value: _104.MsgClaimFreeAmount): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                createAirdrop(value: _104.MsgCreateAirdrop): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                deleteAirdrop(value: _104.MsgDeleteAirdrop): {
                    typeUrl: string;
                    value: Uint8Array;
                };
            };
            withTypeUrl: {
                setAirdropAllocations(value: _104.MsgSetAirdropAllocations): {
                    typeUrl: string;
                    value: _104.MsgSetAirdropAllocations;
                };
                claimFreeAmount(value: _104.MsgClaimFreeAmount): {
                    typeUrl: string;
                    value: _104.MsgClaimFreeAmount;
                };
                createAirdrop(value: _104.MsgCreateAirdrop): {
                    typeUrl: string;
                    value: _104.MsgCreateAirdrop;
                };
                deleteAirdrop(value: _104.MsgDeleteAirdrop): {
                    typeUrl: string;
                    value: _104.MsgDeleteAirdrop;
                };
            };
            fromPartial: {
                setAirdropAllocations(value: _104.MsgSetAirdropAllocations): {
                    typeUrl: string;
                    value: _104.MsgSetAirdropAllocations;
                };
                claimFreeAmount(value: _104.MsgClaimFreeAmount): {
                    typeUrl: string;
                    value: _104.MsgClaimFreeAmount;
                };
                createAirdrop(value: _104.MsgCreateAirdrop): {
                    typeUrl: string;
                    value: _104.MsgCreateAirdrop;
                };
                deleteAirdrop(value: _104.MsgDeleteAirdrop): {
                    typeUrl: string;
                    value: _104.MsgDeleteAirdrop;
                };
            };
        };
        AminoConverter: {
            "/stride.claim.MsgSetAirdropAllocations": {
                aminoType: string;
                toAmino: ({ allocator, airdropIdentifier, users, weights }: _104.MsgSetAirdropAllocations) => {
                    allocator: string;
                    airdrop_identifier: string;
                    users: string[];
                    weights: string[];
                };
                fromAmino: ({ allocator, airdrop_identifier, users, weights }: {
                    allocator: string;
                    airdrop_identifier: string;
                    users: string[];
                    weights: string[];
                }) => _104.MsgSetAirdropAllocations;
            };
            "/stride.claim.MsgClaimFreeAmount": {
                aminoType: string;
                toAmino: ({ user }: _104.MsgClaimFreeAmount) => {
                    user: string;
                };
                fromAmino: ({ user }: {
                    user: string;
                }) => _104.MsgClaimFreeAmount;
            };
            "/stride.claim.MsgCreateAirdrop": {
                aminoType: string;
                toAmino: ({ distributor, identifier, chainId, denom, startTime, duration, autopilotEnabled }: _104.MsgCreateAirdrop) => {
                    distributor: string;
                    identifier: string;
                    chain_id: string;
                    denom: string;
                    start_time: string;
                    duration: string;
                    autopilot_enabled: boolean;
                };
                fromAmino: ({ distributor, identifier, chain_id, denom, start_time, duration, autopilot_enabled }: {
                    distributor: string;
                    identifier: string;
                    chain_id: string;
                    denom: string;
                    start_time: string;
                    duration: string;
                    autopilot_enabled: boolean;
                }) => _104.MsgCreateAirdrop;
            };
            "/stride.claim.MsgDeleteAirdrop": {
                aminoType: string;
                toAmino: ({ distributor, identifier }: _104.MsgDeleteAirdrop) => {
                    distributor: string;
                    identifier: string;
                };
                fromAmino: ({ distributor, identifier }: {
                    distributor: string;
                    identifier: string;
                }) => _104.MsgDeleteAirdrop;
            };
        };
        MsgSetAirdropAllocations: {
            encode(message: _104.MsgSetAirdropAllocations, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _104.MsgSetAirdropAllocations;
            fromPartial(object: {
                allocator?: string;
                airdropIdentifier?: string;
                users?: string[];
                weights?: string[];
            }): _104.MsgSetAirdropAllocations;
        };
        MsgSetAirdropAllocationsResponse: {
            encode(_: _104.MsgSetAirdropAllocationsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _104.MsgSetAirdropAllocationsResponse;
            fromPartial(_: {}): _104.MsgSetAirdropAllocationsResponse;
        };
        MsgClaimFreeAmount: {
            encode(message: _104.MsgClaimFreeAmount, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _104.MsgClaimFreeAmount;
            fromPartial(object: {
                user?: string;
            }): _104.MsgClaimFreeAmount;
        };
        MsgClaimFreeAmountResponse: {
            encode(message: _104.MsgClaimFreeAmountResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _104.MsgClaimFreeAmountResponse;
            fromPartial(object: {
                claimedAmount?: {
                    denom?: string;
                    amount?: string;
                }[];
            }): _104.MsgClaimFreeAmountResponse;
        };
        MsgCreateAirdrop: {
            encode(message: _104.MsgCreateAirdrop, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _104.MsgCreateAirdrop;
            fromPartial(object: {
                distributor?: string;
                identifier?: string;
                chainId?: string;
                denom?: string;
                startTime?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                duration?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                autopilotEnabled?: boolean;
            }): _104.MsgCreateAirdrop;
        };
        MsgCreateAirdropResponse: {
            encode(_: _104.MsgCreateAirdropResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _104.MsgCreateAirdropResponse;
            fromPartial(_: {}): _104.MsgCreateAirdropResponse;
        };
        MsgDeleteAirdrop: {
            encode(message: _104.MsgDeleteAirdrop, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _104.MsgDeleteAirdrop;
            fromPartial(object: {
                distributor?: string;
                identifier?: string;
            }): _104.MsgDeleteAirdrop;
        };
        MsgDeleteAirdropResponse: {
            encode(_: _104.MsgDeleteAirdropResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _104.MsgDeleteAirdropResponse;
            fromPartial(_: {}): _104.MsgDeleteAirdropResponse;
        };
        ClaimStatus: {
            encode(message: _103.ClaimStatus, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _103.ClaimStatus;
            fromPartial(object: {
                airdropIdentifier?: string;
                claimed?: boolean;
            }): _103.ClaimStatus;
        };
        QueryClaimStatusRequest: {
            encode(message: _103.QueryClaimStatusRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _103.QueryClaimStatusRequest;
            fromPartial(object: {
                address?: string;
            }): _103.QueryClaimStatusRequest;
        };
        QueryClaimStatusResponse: {
            encode(message: _103.QueryClaimStatusResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _103.QueryClaimStatusResponse;
            fromPartial(object: {
                claimStatus?: {
                    airdropIdentifier?: string;
                    claimed?: boolean;
                }[];
            }): _103.QueryClaimStatusResponse;
        };
        ClaimMetadata: {
            encode(message: _103.ClaimMetadata, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _103.ClaimMetadata;
            fromPartial(object: {
                airdropIdentifier?: string;
                currentRound?: string;
                currentRoundStart?: Date;
                currentRoundEnd?: Date;
            }): _103.ClaimMetadata;
        };
        QueryClaimMetadataRequest: {
            encode(_: _103.QueryClaimMetadataRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _103.QueryClaimMetadataRequest;
            fromPartial(_: {}): _103.QueryClaimMetadataRequest;
        };
        QueryClaimMetadataResponse: {
            encode(message: _103.QueryClaimMetadataResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _103.QueryClaimMetadataResponse;
            fromPartial(object: {
                claimMetadata?: {
                    airdropIdentifier?: string;
                    currentRound?: string;
                    currentRoundStart?: Date;
                    currentRoundEnd?: Date;
                }[];
            }): _103.QueryClaimMetadataResponse;
        };
        QueryDistributorAccountBalanceRequest: {
            encode(message: _103.QueryDistributorAccountBalanceRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _103.QueryDistributorAccountBalanceRequest;
            fromPartial(object: {
                airdropIdentifier?: string;
            }): _103.QueryDistributorAccountBalanceRequest;
        };
        QueryDistributorAccountBalanceResponse: {
            encode(message: _103.QueryDistributorAccountBalanceResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _103.QueryDistributorAccountBalanceResponse;
            fromPartial(object: {
                distributorAccountBalance?: {
                    denom?: string;
                    amount?: string;
                }[];
            }): _103.QueryDistributorAccountBalanceResponse;
        };
        QueryParamsRequest: {
            encode(_: _103.QueryParamsRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _103.QueryParamsRequest;
            fromPartial(_: {}): _103.QueryParamsRequest;
        };
        QueryParamsResponse: {
            encode(message: _103.QueryParamsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _103.QueryParamsResponse;
            fromPartial(object: {
                params?: {
                    airdrops?: {
                        airdropIdentifier?: string;
                        chainId?: string;
                        airdropStartTime?: Date;
                        airdropDuration?: {
                            seconds?: {
                                high?: number;
                                low?: number;
                                unsigned?: boolean;
                                add?: (addend: string | number | import("long").default) => import("long").default;
                                and?: (other: string | number | import("long").default) => import("long").default;
                                compare?: (other: string | number | import("long").default) => number;
                                comp?: (other: string | number | import("long").default) => number;
                                divide?: (divisor: string | number | import("long").default) => import("long").default;
                                div?: (divisor: string | number | import("long").default) => import("long").default;
                                equals?: (other: string | number | import("long").default) => boolean;
                                eq?: (other: string | number | import("long").default) => boolean;
                                getHighBits?: () => number;
                                getHighBitsUnsigned?: () => number;
                                getLowBits?: () => number;
                                getLowBitsUnsigned?: () => number;
                                getNumBitsAbs?: () => number;
                                greaterThan?: (other: string | number | import("long").default) => boolean;
                                gt?: (other: string | number | import("long").default) => boolean;
                                greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                                gte?: (other: string | number | import("long").default) => boolean;
                                ge?: (other: string | number | import("long").default) => boolean;
                                isEven?: () => boolean;
                                isNegative?: () => boolean;
                                isOdd?: () => boolean;
                                isPositive?: () => boolean;
                                isZero?: () => boolean;
                                eqz?: () => boolean;
                                lessThan?: (other: string | number | import("long").default) => boolean;
                                lt?: (other: string | number | import("long").default) => boolean;
                                lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                                lte?: (other: string | number | import("long").default) => boolean;
                                le?: (other: string | number | import("long").default) => boolean;
                                modulo?: (other: string | number | import("long").default) => import("long").default;
                                mod?: (other: string | number | import("long").default) => import("long").default;
                                rem?: (other: string | number | import("long").default) => import("long").default;
                                multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                                mul?: (multiplier: string | number | import("long").default) => import("long").default;
                                negate?: () => import("long").default;
                                neg?: () => import("long").default;
                                not?: () => import("long").default;
                                countLeadingZeros?: () => number;
                                clz?: () => number;
                                countTrailingZeros?: () => number;
                                ctz?: () => number;
                                notEquals?: (other: string | number | import("long").default) => boolean;
                                neq?: (other: string | number | import("long").default) => boolean;
                                ne?: (other: string | number | import("long").default) => boolean;
                                or?: (other: string | number | import("long").default) => import("long").default;
                                shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                                shl?: (numBits: number | import("long").default) => import("long").default;
                                shiftRight?: (numBits: number | import("long").default) => import("long").default;
                                shr?: (numBits: number | import("long").default) => import("long").default;
                                shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                                shru?: (numBits: number | import("long").default) => import("long").default;
                                shr_u?: (numBits: number | import("long").default) => import("long").default;
                                rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                                rotl?: (numBits: number | import("long").default) => import("long").default;
                                rotateRight?: (numBits: number | import("long").default) => import("long").default;
                                rotr?: (numBits: number | import("long").default) => import("long").default;
                                subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                                sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                                toInt?: () => number;
                                toNumber?: () => number;
                                toBytes?: (le?: boolean) => number[];
                                toBytesLE?: () => number[];
                                toBytesBE?: () => number[];
                                toSigned?: () => import("long").default;
                                toString?: (radix?: number) => string;
                                toUnsigned?: () => import("long").default;
                                xor?: (other: string | number | import("long").default) => import("long").default;
                            };
                            nanos?: number;
                        };
                        claimDenom?: string;
                        distributorAddress?: string;
                        claimedSoFar?: string;
                        autopilotEnabled?: boolean;
                    }[];
                };
            }): _103.QueryParamsResponse;
        };
        QueryClaimRecordRequest: {
            encode(message: _103.QueryClaimRecordRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _103.QueryClaimRecordRequest;
            fromPartial(object: {
                airdropIdentifier?: string;
                address?: string;
            }): _103.QueryClaimRecordRequest;
        };
        QueryClaimRecordResponse: {
            encode(message: _103.QueryClaimRecordResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _103.QueryClaimRecordResponse;
            fromPartial(object: {
                claimRecord?: {
                    airdropIdentifier?: string;
                    address?: string;
                    weight?: string;
                    actionCompleted?: boolean[];
                };
            }): _103.QueryClaimRecordResponse;
        };
        QueryClaimableForActionRequest: {
            encode(message: _103.QueryClaimableForActionRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _103.QueryClaimableForActionRequest;
            fromPartial(object: {
                airdropIdentifier?: string;
                address?: string;
                action?: _100.Action;
            }): _103.QueryClaimableForActionRequest;
        };
        QueryClaimableForActionResponse: {
            encode(message: _103.QueryClaimableForActionResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _103.QueryClaimableForActionResponse;
            fromPartial(object: {
                coins?: {
                    denom?: string;
                    amount?: string;
                }[];
            }): _103.QueryClaimableForActionResponse;
        };
        QueryTotalClaimableRequest: {
            encode(message: _103.QueryTotalClaimableRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _103.QueryTotalClaimableRequest;
            fromPartial(object: {
                airdropIdentifier?: string;
                address?: string;
                includeClaimed?: boolean;
            }): _103.QueryTotalClaimableRequest;
        };
        QueryTotalClaimableResponse: {
            encode(message: _103.QueryTotalClaimableResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _103.QueryTotalClaimableResponse;
            fromPartial(object: {
                coins?: {
                    denom?: string;
                    amount?: string;
                }[];
            }): _103.QueryTotalClaimableResponse;
        };
        QueryUserVestingsRequest: {
            encode(message: _103.QueryUserVestingsRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _103.QueryUserVestingsRequest;
            fromPartial(object: {
                address?: string;
            }): _103.QueryUserVestingsRequest;
        };
        QueryUserVestingsResponse: {
            encode(message: _103.QueryUserVestingsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _103.QueryUserVestingsResponse;
            fromPartial(object: {
                spendableCoins?: {
                    denom?: string;
                    amount?: string;
                }[];
                periods?: {
                    startTime?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    length?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    amount?: {
                        denom?: string;
                        amount?: string;
                    }[];
                    actionType?: number;
                }[];
            }): _103.QueryUserVestingsResponse;
        };
        Params: {
            encode(message: _102.Params, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _102.Params;
            fromPartial(object: {
                airdrops?: {
                    airdropIdentifier?: string;
                    chainId?: string;
                    airdropStartTime?: Date;
                    airdropDuration?: {
                        seconds?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        nanos?: number;
                    };
                    claimDenom?: string;
                    distributorAddress?: string;
                    claimedSoFar?: string;
                    autopilotEnabled?: boolean;
                }[];
            }): _102.Params;
        };
        Airdrop: {
            encode(message: _102.Airdrop, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _102.Airdrop;
            fromPartial(object: {
                airdropIdentifier?: string;
                chainId?: string;
                airdropStartTime?: Date;
                airdropDuration?: {
                    seconds?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    nanos?: number;
                };
                claimDenom?: string;
                distributorAddress?: string;
                claimedSoFar?: string;
                autopilotEnabled?: boolean;
            }): _102.Airdrop;
        };
        GenesisState: {
            encode(message: _101.GenesisState, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _101.GenesisState;
            fromPartial(object: {
                params?: {
                    airdrops?: {
                        airdropIdentifier?: string;
                        chainId?: string;
                        airdropStartTime?: Date;
                        airdropDuration?: {
                            seconds?: {
                                high?: number;
                                low?: number;
                                unsigned?: boolean;
                                add?: (addend: string | number | import("long").default) => import("long").default;
                                and?: (other: string | number | import("long").default) => import("long").default;
                                compare?: (other: string | number | import("long").default) => number;
                                comp?: (other: string | number | import("long").default) => number;
                                divide?: (divisor: string | number | import("long").default) => import("long").default;
                                div?: (divisor: string | number | import("long").default) => import("long").default;
                                equals?: (other: string | number | import("long").default) => boolean;
                                eq?: (other: string | number | import("long").default) => boolean;
                                getHighBits?: () => number;
                                getHighBitsUnsigned?: () => number;
                                getLowBits?: () => number;
                                getLowBitsUnsigned?: () => number;
                                getNumBitsAbs?: () => number;
                                greaterThan?: (other: string | number | import("long").default) => boolean;
                                gt?: (other: string | number | import("long").default) => boolean;
                                greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                                gte?: (other: string | number | import("long").default) => boolean;
                                ge?: (other: string | number | import("long").default) => boolean;
                                isEven?: () => boolean;
                                isNegative?: () => boolean;
                                isOdd?: () => boolean;
                                isPositive?: () => boolean;
                                isZero?: () => boolean;
                                eqz?: () => boolean;
                                lessThan?: (other: string | number | import("long").default) => boolean;
                                lt?: (other: string | number | import("long").default) => boolean;
                                lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                                lte?: (other: string | number | import("long").default) => boolean;
                                le?: (other: string | number | import("long").default) => boolean;
                                modulo?: (other: string | number | import("long").default) => import("long").default;
                                mod?: (other: string | number | import("long").default) => import("long").default;
                                rem?: (other: string | number | import("long").default) => import("long").default;
                                multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                                mul?: (multiplier: string | number | import("long").default) => import("long").default;
                                negate?: () => import("long").default;
                                neg?: () => import("long").default;
                                not?: () => import("long").default;
                                countLeadingZeros?: () => number;
                                clz?: () => number;
                                countTrailingZeros?: () => number;
                                ctz?: () => number;
                                notEquals?: (other: string | number | import("long").default) => boolean;
                                neq?: (other: string | number | import("long").default) => boolean;
                                ne?: (other: string | number | import("long").default) => boolean;
                                or?: (other: string | number | import("long").default) => import("long").default;
                                shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                                shl?: (numBits: number | import("long").default) => import("long").default;
                                shiftRight?: (numBits: number | import("long").default) => import("long").default;
                                shr?: (numBits: number | import("long").default) => import("long").default;
                                shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                                shru?: (numBits: number | import("long").default) => import("long").default;
                                shr_u?: (numBits: number | import("long").default) => import("long").default;
                                rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                                rotl?: (numBits: number | import("long").default) => import("long").default;
                                rotateRight?: (numBits: number | import("long").default) => import("long").default;
                                rotr?: (numBits: number | import("long").default) => import("long").default;
                                subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                                sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                                toInt?: () => number;
                                toNumber?: () => number;
                                toBytes?: (le?: boolean) => number[];
                                toBytesLE?: () => number[];
                                toBytesBE?: () => number[];
                                toSigned?: () => import("long").default;
                                toString?: (radix?: number) => string;
                                toUnsigned?: () => import("long").default;
                                xor?: (other: string | number | import("long").default) => import("long").default;
                            };
                            nanos?: number;
                        };
                        claimDenom?: string;
                        distributorAddress?: string;
                        claimedSoFar?: string;
                        autopilotEnabled?: boolean;
                    }[];
                };
                claimRecords?: {
                    airdropIdentifier?: string;
                    address?: string;
                    weight?: string;
                    actionCompleted?: boolean[];
                }[];
            }): _101.GenesisState;
        };
        actionFromJSON(object: any): _100.Action;
        actionToJSON(object: _100.Action): string;
        Action: typeof _100.Action;
        ActionSDKType: typeof _100.ActionSDKType;
        ClaimRecord: {
            encode(message: _100.ClaimRecord, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _100.ClaimRecord;
            fromPartial(object: {
                airdropIdentifier?: string;
                address?: string;
                weight?: string;
                actionCompleted?: boolean[];
            }): _100.ClaimRecord;
        };
    };
    const epochs: {
        QueryClientImpl: typeof _254.QueryClientImpl;
        createRpcQueryExtension: (base: import("@cosmjs/stargate").QueryClient) => {
            epochInfos(request?: _106.QueryEpochsInfoRequest): Promise<_106.QueryEpochsInfoResponse>;
            currentEpoch(request: _106.QueryCurrentEpochRequest): Promise<_106.QueryCurrentEpochResponse>;
            epochInfo(request: _106.QueryEpochInfoRequest): Promise<_106.QueryEpochInfoResponse>;
        };
        LCDQueryClient: typeof _243.LCDQueryClient;
        QueryEpochsInfoRequest: {
            encode(message: _106.QueryEpochsInfoRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _106.QueryEpochsInfoRequest;
            fromPartial(object: {
                pagination?: {
                    key?: Uint8Array;
                    offset?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    limit?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    countTotal?: boolean;
                    reverse?: boolean;
                };
            }): _106.QueryEpochsInfoRequest;
        };
        QueryEpochsInfoResponse: {
            encode(message: _106.QueryEpochsInfoResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _106.QueryEpochsInfoResponse;
            fromPartial(object: {
                epochs?: {
                    identifier?: string;
                    startTime?: Date;
                    duration?: {
                        seconds?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        nanos?: number;
                    };
                    currentEpoch?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    currentEpochStartTime?: Date;
                    epochCountingStarted?: boolean;
                    currentEpochStartHeight?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                }[];
                pagination?: {
                    nextKey?: Uint8Array;
                    total?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                };
            }): _106.QueryEpochsInfoResponse;
        };
        QueryCurrentEpochRequest: {
            encode(message: _106.QueryCurrentEpochRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _106.QueryCurrentEpochRequest;
            fromPartial(object: {
                identifier?: string;
            }): _106.QueryCurrentEpochRequest;
        };
        QueryCurrentEpochResponse: {
            encode(message: _106.QueryCurrentEpochResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _106.QueryCurrentEpochResponse;
            fromPartial(object: {
                currentEpoch?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
            }): _106.QueryCurrentEpochResponse;
        };
        QueryEpochInfoRequest: {
            encode(message: _106.QueryEpochInfoRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _106.QueryEpochInfoRequest;
            fromPartial(object: {
                identifier?: string;
            }): _106.QueryEpochInfoRequest;
        };
        QueryEpochInfoResponse: {
            encode(message: _106.QueryEpochInfoResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _106.QueryEpochInfoResponse;
            fromPartial(object: {
                epoch?: {
                    identifier?: string;
                    startTime?: Date;
                    duration?: {
                        seconds?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        nanos?: number;
                    };
                    currentEpoch?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    currentEpochStartTime?: Date;
                    epochCountingStarted?: boolean;
                    currentEpochStartHeight?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                };
            }): _106.QueryEpochInfoResponse;
        };
        EpochInfo: {
            encode(message: _105.EpochInfo, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _105.EpochInfo;
            fromPartial(object: {
                identifier?: string;
                startTime?: Date;
                duration?: {
                    seconds?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    nanos?: number;
                };
                currentEpoch?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                currentEpochStartTime?: Date;
                epochCountingStarted?: boolean;
                currentEpochStartHeight?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
            }): _105.EpochInfo;
        };
        GenesisState: {
            encode(message: _105.GenesisState, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _105.GenesisState;
            fromPartial(object: {
                epochs?: {
                    identifier?: string;
                    startTime?: Date;
                    duration?: {
                        seconds?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        nanos?: number;
                    };
                    currentEpoch?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    currentEpochStartTime?: Date;
                    epochCountingStarted?: boolean;
                    currentEpochStartHeight?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                }[];
            }): _105.GenesisState;
        };
    };
    const icacallbacks: {
        QueryClientImpl: typeof _255.QueryClientImpl;
        createRpcQueryExtension: (base: import("@cosmjs/stargate").QueryClient) => {
            params(request?: _111.QueryParamsRequest): Promise<_111.QueryParamsResponse>;
            callbackData(request: _111.QueryGetCallbackDataRequest): Promise<_111.QueryGetCallbackDataResponse>;
            callbackDataAll(request?: _111.QueryAllCallbackDataRequest): Promise<_111.QueryAllCallbackDataResponse>;
        };
        LCDQueryClient: typeof _244.LCDQueryClient;
        QueryParamsRequest: {
            encode(_: _111.QueryParamsRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _111.QueryParamsRequest;
            fromPartial(_: {}): _111.QueryParamsRequest;
        };
        QueryParamsResponse: {
            encode(message: _111.QueryParamsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _111.QueryParamsResponse;
            fromPartial(object: {
                params?: {};
            }): _111.QueryParamsResponse;
        };
        QueryGetCallbackDataRequest: {
            encode(message: _111.QueryGetCallbackDataRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _111.QueryGetCallbackDataRequest;
            fromPartial(object: {
                callbackKey?: string;
            }): _111.QueryGetCallbackDataRequest;
        };
        QueryGetCallbackDataResponse: {
            encode(message: _111.QueryGetCallbackDataResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _111.QueryGetCallbackDataResponse;
            fromPartial(object: {
                callbackData?: {
                    callbackKey?: string;
                    portId?: string;
                    channelId?: string;
                    sequence?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    callbackId?: string;
                    callbackArgs?: Uint8Array;
                };
            }): _111.QueryGetCallbackDataResponse;
        };
        QueryAllCallbackDataRequest: {
            encode(message: _111.QueryAllCallbackDataRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _111.QueryAllCallbackDataRequest;
            fromPartial(object: {
                pagination?: {
                    key?: Uint8Array;
                    offset?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    limit?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    countTotal?: boolean;
                    reverse?: boolean;
                };
            }): _111.QueryAllCallbackDataRequest;
        };
        QueryAllCallbackDataResponse: {
            encode(message: _111.QueryAllCallbackDataResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _111.QueryAllCallbackDataResponse;
            fromPartial(object: {
                callbackData?: {
                    callbackKey?: string;
                    portId?: string;
                    channelId?: string;
                    sequence?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    callbackId?: string;
                    callbackArgs?: Uint8Array;
                }[];
                pagination?: {
                    nextKey?: Uint8Array;
                    total?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                };
            }): _111.QueryAllCallbackDataResponse;
        };
        Params: {
            encode(_: _110.Params, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _110.Params;
            fromPartial(_: {}): _110.Params;
        };
        IcacallbacksPacketData: {
            encode(message: _109.IcacallbacksPacketData, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _109.IcacallbacksPacketData;
            fromPartial(object: {
                noData?: {};
            }): _109.IcacallbacksPacketData;
        };
        NoData: {
            encode(_: _109.NoData, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _109.NoData;
            fromPartial(_: {}): _109.NoData;
        };
        GenesisState: {
            encode(message: _108.GenesisState, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _108.GenesisState;
            fromPartial(object: {
                params?: {};
                portId?: string;
                callbackDataList?: {
                    callbackKey?: string;
                    portId?: string;
                    channelId?: string;
                    sequence?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    callbackId?: string;
                    callbackArgs?: Uint8Array;
                }[];
            }): _108.GenesisState;
        };
        CallbackData: {
            encode(message: _107.CallbackData, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _107.CallbackData;
            fromPartial(object: {
                callbackKey?: string;
                portId?: string;
                channelId?: string;
                sequence?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                callbackId?: string;
                callbackArgs?: Uint8Array;
            }): _107.CallbackData;
        };
    };
    const icaoracle: {
        MsgClientImpl: typeof _264.MsgClientImpl;
        QueryClientImpl: typeof _256.QueryClientImpl;
        createRpcQueryExtension: (base: import("@cosmjs/stargate").QueryClient) => {
            oracle(request: _117.QueryOracleRequest): Promise<_117.QueryOracleResponse>;
            allOracles(request?: _117.QueryAllOraclesRequest): Promise<_117.QueryAllOraclesResponse>;
            activeOracles(request: _117.QueryActiveOraclesRequest): Promise<_117.QueryActiveOraclesResponse>;
            metrics(request: _117.QueryMetricsRequest): Promise<_117.QueryMetricsResponse>;
        };
        LCDQueryClient: typeof _245.LCDQueryClient;
        registry: readonly [string, import("@cosmjs/proto-signing").GeneratedType][];
        load: (protoRegistry: import("@cosmjs/proto-signing").Registry) => void;
        MessageComposer: {
            encoded: {
                addOracle(value: _118.MsgAddOracle): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                instantiateOracle(value: _118.MsgInstantiateOracle): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                restoreOracleICA(value: _118.MsgRestoreOracleICA): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                toggleOracle(value: _118.MsgToggleOracle): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                removeOracle(value: _118.MsgRemoveOracle): {
                    typeUrl: string;
                    value: Uint8Array;
                };
            };
            withTypeUrl: {
                addOracle(value: _118.MsgAddOracle): {
                    typeUrl: string;
                    value: _118.MsgAddOracle;
                };
                instantiateOracle(value: _118.MsgInstantiateOracle): {
                    typeUrl: string;
                    value: _118.MsgInstantiateOracle;
                };
                restoreOracleICA(value: _118.MsgRestoreOracleICA): {
                    typeUrl: string;
                    value: _118.MsgRestoreOracleICA;
                };
                toggleOracle(value: _118.MsgToggleOracle): {
                    typeUrl: string;
                    value: _118.MsgToggleOracle;
                };
                removeOracle(value: _118.MsgRemoveOracle): {
                    typeUrl: string;
                    value: _118.MsgRemoveOracle;
                };
            };
            fromPartial: {
                addOracle(value: _118.MsgAddOracle): {
                    typeUrl: string;
                    value: _118.MsgAddOracle;
                };
                instantiateOracle(value: _118.MsgInstantiateOracle): {
                    typeUrl: string;
                    value: _118.MsgInstantiateOracle;
                };
                restoreOracleICA(value: _118.MsgRestoreOracleICA): {
                    typeUrl: string;
                    value: _118.MsgRestoreOracleICA;
                };
                toggleOracle(value: _118.MsgToggleOracle): {
                    typeUrl: string;
                    value: _118.MsgToggleOracle;
                };
                removeOracle(value: _118.MsgRemoveOracle): {
                    typeUrl: string;
                    value: _118.MsgRemoveOracle;
                };
            };
        };
        AminoConverter: {
            "/stride.icaoracle.MsgAddOracle": {
                aminoType: string;
                toAmino: ({ creator, connectionId }: _118.MsgAddOracle) => {
                    creator: string;
                    connection_id: string;
                };
                fromAmino: ({ creator, connection_id }: {
                    creator: string;
                    connection_id: string;
                }) => _118.MsgAddOracle;
            };
            "/stride.icaoracle.MsgInstantiateOracle": {
                aminoType: string;
                toAmino: ({ creator, oracleChainId, contractCodeId, transferChannelOnOracle }: _118.MsgInstantiateOracle) => {
                    creator: string;
                    oracle_chain_id: string;
                    contract_code_id: string;
                    transfer_channel_on_oracle: string;
                };
                fromAmino: ({ creator, oracle_chain_id, contract_code_id, transfer_channel_on_oracle }: {
                    creator: string;
                    oracle_chain_id: string;
                    contract_code_id: string;
                    transfer_channel_on_oracle: string;
                }) => _118.MsgInstantiateOracle;
            };
            "/stride.icaoracle.MsgRestoreOracleICA": {
                aminoType: string;
                toAmino: ({ creator, oracleChainId }: _118.MsgRestoreOracleICA) => {
                    creator: string;
                    oracle_chain_id: string;
                };
                fromAmino: ({ creator, oracle_chain_id }: {
                    creator: string;
                    oracle_chain_id: string;
                }) => _118.MsgRestoreOracleICA;
            };
            "/stride.icaoracle.MsgToggleOracle": {
                aminoType: string;
                toAmino: ({ authority, oracleChainId, active }: _118.MsgToggleOracle) => {
                    authority: string;
                    oracle_chain_id: string;
                    active: boolean;
                };
                fromAmino: ({ authority, oracle_chain_id, active }: {
                    authority: string;
                    oracle_chain_id: string;
                    active: boolean;
                }) => _118.MsgToggleOracle;
            };
            "/stride.icaoracle.MsgRemoveOracle": {
                aminoType: string;
                toAmino: ({ authority, oracleChainId }: _118.MsgRemoveOracle) => {
                    authority: string;
                    oracle_chain_id: string;
                };
                fromAmino: ({ authority, oracle_chain_id }: {
                    authority: string;
                    oracle_chain_id: string;
                }) => _118.MsgRemoveOracle;
            };
        };
        MsgAddOracle: {
            encode(message: _118.MsgAddOracle, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _118.MsgAddOracle;
            fromPartial(object: {
                creator?: string;
                connectionId?: string;
            }): _118.MsgAddOracle;
        };
        MsgAddOracleResponse: {
            encode(_: _118.MsgAddOracleResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _118.MsgAddOracleResponse;
            fromPartial(_: {}): _118.MsgAddOracleResponse;
        };
        MsgInstantiateOracle: {
            encode(message: _118.MsgInstantiateOracle, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _118.MsgInstantiateOracle;
            fromPartial(object: {
                creator?: string;
                oracleChainId?: string;
                contractCodeId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                transferChannelOnOracle?: string;
            }): _118.MsgInstantiateOracle;
        };
        MsgInstantiateOracleResponse: {
            encode(_: _118.MsgInstantiateOracleResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _118.MsgInstantiateOracleResponse;
            fromPartial(_: {}): _118.MsgInstantiateOracleResponse;
        };
        MsgRestoreOracleICA: {
            encode(message: _118.MsgRestoreOracleICA, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _118.MsgRestoreOracleICA;
            fromPartial(object: {
                creator?: string;
                oracleChainId?: string;
            }): _118.MsgRestoreOracleICA;
        };
        MsgRestoreOracleICAResponse: {
            encode(_: _118.MsgRestoreOracleICAResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _118.MsgRestoreOracleICAResponse;
            fromPartial(_: {}): _118.MsgRestoreOracleICAResponse;
        };
        MsgToggleOracle: {
            encode(message: _118.MsgToggleOracle, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _118.MsgToggleOracle;
            fromPartial(object: {
                authority?: string;
                oracleChainId?: string;
                active?: boolean;
            }): _118.MsgToggleOracle;
        };
        MsgToggleOracleResponse: {
            encode(_: _118.MsgToggleOracleResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _118.MsgToggleOracleResponse;
            fromPartial(_: {}): _118.MsgToggleOracleResponse;
        };
        MsgRemoveOracle: {
            encode(message: _118.MsgRemoveOracle, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _118.MsgRemoveOracle;
            fromPartial(object: {
                authority?: string;
                oracleChainId?: string;
            }): _118.MsgRemoveOracle;
        };
        MsgRemoveOracleResponse: {
            encode(_: _118.MsgRemoveOracleResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _118.MsgRemoveOracleResponse;
            fromPartial(_: {}): _118.MsgRemoveOracleResponse;
        };
        QueryOracleRequest: {
            encode(message: _117.QueryOracleRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _117.QueryOracleRequest;
            fromPartial(object: {
                chainId?: string;
            }): _117.QueryOracleRequest;
        };
        QueryOracleResponse: {
            encode(message: _117.QueryOracleResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _117.QueryOracleResponse;
            fromPartial(object: {
                oracle?: {
                    chainId?: string;
                    connectionId?: string;
                    channelId?: string;
                    portId?: string;
                    icaAddress?: string;
                    contractAddress?: string;
                    active?: boolean;
                };
            }): _117.QueryOracleResponse;
        };
        QueryAllOraclesRequest: {
            encode(_: _117.QueryAllOraclesRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _117.QueryAllOraclesRequest;
            fromPartial(_: {}): _117.QueryAllOraclesRequest;
        };
        QueryAllOraclesResponse: {
            encode(message: _117.QueryAllOraclesResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _117.QueryAllOraclesResponse;
            fromPartial(object: {
                oracles?: {
                    chainId?: string;
                    connectionId?: string;
                    channelId?: string;
                    portId?: string;
                    icaAddress?: string;
                    contractAddress?: string;
                    active?: boolean;
                }[];
            }): _117.QueryAllOraclesResponse;
        };
        QueryActiveOraclesRequest: {
            encode(message: _117.QueryActiveOraclesRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _117.QueryActiveOraclesRequest;
            fromPartial(object: {
                active?: boolean;
            }): _117.QueryActiveOraclesRequest;
        };
        QueryActiveOraclesResponse: {
            encode(message: _117.QueryActiveOraclesResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _117.QueryActiveOraclesResponse;
            fromPartial(object: {
                oracles?: {
                    chainId?: string;
                    connectionId?: string;
                    channelId?: string;
                    portId?: string;
                    icaAddress?: string;
                    contractAddress?: string;
                    active?: boolean;
                }[];
            }): _117.QueryActiveOraclesResponse;
        };
        QueryMetricsRequest: {
            encode(message: _117.QueryMetricsRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _117.QueryMetricsRequest;
            fromPartial(object: {
                metricKey?: string;
                oracleChainId?: string;
            }): _117.QueryMetricsRequest;
        };
        QueryMetricsResponse: {
            encode(message: _117.QueryMetricsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _117.QueryMetricsResponse;
            fromPartial(object: {
                metrics?: {
                    key?: string;
                    value?: string;
                    metricType?: string;
                    updateTime?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    blockHeight?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    attributes?: string;
                    destinationOracle?: string;
                    status?: _116.MetricStatus;
                }[];
            }): _117.QueryMetricsResponse;
        };
        metricStatusFromJSON(object: any): _116.MetricStatus;
        metricStatusToJSON(object: _116.MetricStatus): string;
        MetricStatus: typeof _116.MetricStatus;
        MetricStatusSDKType: typeof _116.MetricStatusSDKType;
        Oracle: {
            encode(message: _116.Oracle, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _116.Oracle;
            fromPartial(object: {
                chainId?: string;
                connectionId?: string;
                channelId?: string;
                portId?: string;
                icaAddress?: string;
                contractAddress?: string;
                active?: boolean;
            }): _116.Oracle;
        };
        Metric: {
            encode(message: _116.Metric, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _116.Metric;
            fromPartial(object: {
                key?: string;
                value?: string;
                metricType?: string;
                updateTime?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                blockHeight?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                attributes?: string;
                destinationOracle?: string;
                status?: _116.MetricStatus;
            }): _116.Metric;
        };
        RedemptionRateAttributes: {
            encode(message: _116.RedemptionRateAttributes, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _116.RedemptionRateAttributes;
            fromPartial(object: {
                sttokenDenom?: string;
            }): _116.RedemptionRateAttributes;
        };
        Params: {
            encode(_: _115.Params, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _115.Params;
            fromPartial(_: {}): _115.Params;
        };
        GenesisState: {
            encode(message: _115.GenesisState, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _115.GenesisState;
            fromPartial(object: {
                params?: {};
                oracles?: {
                    chainId?: string;
                    connectionId?: string;
                    channelId?: string;
                    portId?: string;
                    icaAddress?: string;
                    contractAddress?: string;
                    active?: boolean;
                }[];
                metrics?: {
                    key?: string;
                    value?: string;
                    metricType?: string;
                    updateTime?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    blockHeight?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    attributes?: string;
                    destinationOracle?: string;
                    status?: _116.MetricStatus;
                }[];
            }): _115.GenesisState;
        };
        MsgInstantiateOracleContract: {
            encode(message: _114.MsgInstantiateOracleContract, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _114.MsgInstantiateOracleContract;
            fromPartial(object: {
                adminAddress?: string;
                transferChannelId?: string;
            }): _114.MsgInstantiateOracleContract;
        };
        MsgExecuteContractPostMetric: {
            encode(message: _114.MsgExecuteContractPostMetric, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _114.MsgExecuteContractPostMetric;
            fromPartial(object: {
                postMetric?: {
                    key?: string;
                    value?: string;
                    metricType?: string;
                    updateTime?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    blockHeight?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    attributes?: string;
                };
            }): _114.MsgExecuteContractPostMetric;
        };
        MsgPostMetric: {
            encode(message: _114.MsgPostMetric, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _114.MsgPostMetric;
            fromPartial(object: {
                key?: string;
                value?: string;
                metricType?: string;
                updateTime?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                blockHeight?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                attributes?: string;
            }): _114.MsgPostMetric;
        };
        InstantiateOracleCallback: {
            encode(message: _113.InstantiateOracleCallback, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _113.InstantiateOracleCallback;
            fromPartial(object: {
                oracleChainId?: string;
            }): _113.InstantiateOracleCallback;
        };
        UpdateOracleCallback: {
            encode(message: _113.UpdateOracleCallback, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _113.UpdateOracleCallback;
            fromPartial(object: {
                oracleChainId?: string;
                metric?: {
                    key?: string;
                    value?: string;
                    metricType?: string;
                    updateTime?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    blockHeight?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    attributes?: string;
                    destinationOracle?: string;
                    status?: _116.MetricStatus;
                };
            }): _113.UpdateOracleCallback;
        };
    };
    namespace interchainquery {
        const v1: {
            MsgClientImpl: typeof _265.MsgClientImpl;
            registry: readonly [string, import("@cosmjs/proto-signing").GeneratedType][];
            load: (protoRegistry: import("@cosmjs/proto-signing").Registry) => void;
            MessageComposer: {
                encoded: {
                    submitQueryResponse(value: _120.MsgSubmitQueryResponse): {
                        typeUrl: string;
                        value: Uint8Array;
                    };
                };
                withTypeUrl: {
                    submitQueryResponse(value: _120.MsgSubmitQueryResponse): {
                        typeUrl: string;
                        value: _120.MsgSubmitQueryResponse;
                    };
                };
                fromPartial: {
                    submitQueryResponse(value: _120.MsgSubmitQueryResponse): {
                        typeUrl: string;
                        value: _120.MsgSubmitQueryResponse;
                    };
                };
            };
            AminoConverter: {
                "/stride.interchainquery.v1.MsgSubmitQueryResponse": {
                    aminoType: string;
                    toAmino: ({ chainId, queryId, result, proofOps, height, fromAddress }: _120.MsgSubmitQueryResponse) => {
                        chain_id: string;
                        query_id: string;
                        result: Uint8Array;
                        proof_ops: {
                            ops: {
                                type: string;
                                key: Uint8Array;
                                data: Uint8Array;
                            }[];
                        };
                        height: string;
                        from_address: string;
                    };
                    fromAmino: ({ chain_id, query_id, result, proof_ops, height, from_address }: {
                        chain_id: string;
                        query_id: string;
                        result: Uint8Array;
                        proof_ops: {
                            ops: {
                                type: string;
                                key: Uint8Array;
                                data: Uint8Array;
                            }[];
                        };
                        height: string;
                        from_address: string;
                    }) => _120.MsgSubmitQueryResponse;
                };
            };
            QueryPendingQueriesRequest: {
                encode(_: _121.QueryPendingQueriesRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _121.QueryPendingQueriesRequest;
                fromPartial(_: {}): _121.QueryPendingQueriesRequest;
            };
            QueryPendingQueriesResponse: {
                encode(message: _121.QueryPendingQueriesResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _121.QueryPendingQueriesResponse;
                fromPartial(object: {
                    pendingQueries?: {
                        id?: string;
                        connectionId?: string;
                        chainId?: string;
                        queryType?: string;
                        requestData?: Uint8Array;
                        callbackModule?: string;
                        callbackId?: string;
                        callbackData?: Uint8Array;
                        timeoutPolicy?: _119.TimeoutPolicy;
                        timeoutDuration?: {
                            seconds?: {
                                high?: number;
                                low?: number;
                                unsigned?: boolean;
                                add?: (addend: string | number | import("long").default) => import("long").default;
                                and?: (other: string | number | import("long").default) => import("long").default;
                                compare?: (other: string | number | import("long").default) => number;
                                comp?: (other: string | number | import("long").default) => number;
                                divide?: (divisor: string | number | import("long").default) => import("long").default;
                                div?: (divisor: string | number | import("long").default) => import("long").default;
                                equals?: (other: string | number | import("long").default) => boolean;
                                eq?: (other: string | number | import("long").default) => boolean;
                                getHighBits?: () => number;
                                getHighBitsUnsigned?: () => number;
                                getLowBits?: () => number;
                                getLowBitsUnsigned?: () => number;
                                getNumBitsAbs?: () => number;
                                greaterThan?: (other: string | number | import("long").default) => boolean;
                                gt?: (other: string | number | import("long").default) => boolean;
                                greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                                gte?: (other: string | number | import("long").default) => boolean;
                                ge?: (other: string | number | import("long").default) => boolean;
                                isEven?: () => boolean;
                                isNegative?: () => boolean;
                                isOdd?: () => boolean;
                                isPositive?: () => boolean;
                                isZero?: () => boolean;
                                eqz?: () => boolean;
                                lessThan?: (other: string | number | import("long").default) => boolean;
                                lt?: (other: string | number | import("long").default) => boolean;
                                lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                                lte?: (other: string | number | import("long").default) => boolean;
                                le?: (other: string | number | import("long").default) => boolean;
                                modulo?: (other: string | number | import("long").default) => import("long").default;
                                mod?: (other: string | number | import("long").default) => import("long").default;
                                rem?: (other: string | number | import("long").default) => import("long").default;
                                multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                                mul?: (multiplier: string | number | import("long").default) => import("long").default;
                                negate?: () => import("long").default;
                                neg?: () => import("long").default;
                                not?: () => import("long").default;
                                countLeadingZeros?: () => number;
                                clz?: () => number;
                                countTrailingZeros?: () => number;
                                ctz?: () => number;
                                notEquals?: (other: string | number | import("long").default) => boolean;
                                neq?: (other: string | number | import("long").default) => boolean;
                                ne?: (other: string | number | import("long").default) => boolean;
                                or?: (other: string | number | import("long").default) => import("long").default;
                                shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                                shl?: (numBits: number | import("long").default) => import("long").default;
                                shiftRight?: (numBits: number | import("long").default) => import("long").default;
                                shr?: (numBits: number | import("long").default) => import("long").default;
                                shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                                shru?: (numBits: number | import("long").default) => import("long").default;
                                shr_u?: (numBits: number | import("long").default) => import("long").default;
                                rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                                rotl?: (numBits: number | import("long").default) => import("long").default;
                                rotateRight?: (numBits: number | import("long").default) => import("long").default;
                                rotr?: (numBits: number | import("long").default) => import("long").default;
                                subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                                sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                                toInt?: () => number;
                                toNumber?: () => number;
                                toBytes?: (le?: boolean) => number[];
                                toBytesLE?: () => number[];
                                toBytesBE?: () => number[];
                                toSigned?: () => import("long").default;
                                toString?: (radix?: number) => string;
                                toUnsigned?: () => import("long").default;
                                xor?: (other: string | number | import("long").default) => import("long").default;
                            };
                            nanos?: number;
                        };
                        timeoutTimestamp?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        requestSent?: boolean;
                        submissionHeight?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                    }[];
                }): _121.QueryPendingQueriesResponse;
            };
            MsgSubmitQueryResponse: {
                encode(message: _120.MsgSubmitQueryResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _120.MsgSubmitQueryResponse;
                fromPartial(object: {
                    chainId?: string;
                    queryId?: string;
                    result?: Uint8Array;
                    proofOps?: {
                        ops?: {
                            type?: string;
                            key?: Uint8Array;
                            data?: Uint8Array;
                        }[];
                    };
                    height?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    fromAddress?: string;
                }): _120.MsgSubmitQueryResponse;
            };
            MsgSubmitQueryResponseResponse: {
                encode(_: _120.MsgSubmitQueryResponseResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _120.MsgSubmitQueryResponseResponse;
                fromPartial(_: {}): _120.MsgSubmitQueryResponseResponse;
            };
            timeoutPolicyFromJSON(object: any): _119.TimeoutPolicy;
            timeoutPolicyToJSON(object: _119.TimeoutPolicy): string;
            TimeoutPolicy: typeof _119.TimeoutPolicy;
            TimeoutPolicySDKType: typeof _119.TimeoutPolicySDKType;
            Query: {
                encode(message: _119.Query, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _119.Query;
                fromPartial(object: {
                    id?: string;
                    connectionId?: string;
                    chainId?: string;
                    queryType?: string;
                    requestData?: Uint8Array;
                    callbackModule?: string;
                    callbackId?: string;
                    callbackData?: Uint8Array;
                    timeoutPolicy?: _119.TimeoutPolicy;
                    timeoutDuration?: {
                        seconds?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        nanos?: number;
                    };
                    timeoutTimestamp?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    requestSent?: boolean;
                    submissionHeight?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                }): _119.Query;
            };
            DataPoint: {
                encode(message: _119.DataPoint, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _119.DataPoint;
                fromPartial(object: {
                    id?: string;
                    remoteHeight?: string;
                    localHeight?: string;
                    value?: Uint8Array;
                }): _119.DataPoint;
            };
            GenesisState: {
                encode(message: _119.GenesisState, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _119.GenesisState;
                fromPartial(object: {
                    queries?: {
                        id?: string;
                        connectionId?: string;
                        chainId?: string;
                        queryType?: string;
                        requestData?: Uint8Array;
                        callbackModule?: string;
                        callbackId?: string;
                        callbackData?: Uint8Array;
                        timeoutPolicy?: _119.TimeoutPolicy;
                        timeoutDuration?: {
                            seconds?: {
                                high?: number;
                                low?: number;
                                unsigned?: boolean;
                                add?: (addend: string | number | import("long").default) => import("long").default;
                                and?: (other: string | number | import("long").default) => import("long").default;
                                compare?: (other: string | number | import("long").default) => number;
                                comp?: (other: string | number | import("long").default) => number;
                                divide?: (divisor: string | number | import("long").default) => import("long").default;
                                div?: (divisor: string | number | import("long").default) => import("long").default;
                                equals?: (other: string | number | import("long").default) => boolean;
                                eq?: (other: string | number | import("long").default) => boolean;
                                getHighBits?: () => number;
                                getHighBitsUnsigned?: () => number;
                                getLowBits?: () => number;
                                getLowBitsUnsigned?: () => number;
                                getNumBitsAbs?: () => number;
                                greaterThan?: (other: string | number | import("long").default) => boolean;
                                gt?: (other: string | number | import("long").default) => boolean;
                                greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                                gte?: (other: string | number | import("long").default) => boolean;
                                ge?: (other: string | number | import("long").default) => boolean;
                                isEven?: () => boolean;
                                isNegative?: () => boolean;
                                isOdd?: () => boolean;
                                isPositive?: () => boolean;
                                isZero?: () => boolean;
                                eqz?: () => boolean;
                                lessThan?: (other: string | number | import("long").default) => boolean;
                                lt?: (other: string | number | import("long").default) => boolean;
                                lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                                lte?: (other: string | number | import("long").default) => boolean;
                                le?: (other: string | number | import("long").default) => boolean;
                                modulo?: (other: string | number | import("long").default) => import("long").default;
                                mod?: (other: string | number | import("long").default) => import("long").default;
                                rem?: (other: string | number | import("long").default) => import("long").default;
                                multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                                mul?: (multiplier: string | number | import("long").default) => import("long").default;
                                negate?: () => import("long").default;
                                neg?: () => import("long").default;
                                not?: () => import("long").default;
                                countLeadingZeros?: () => number;
                                clz?: () => number;
                                countTrailingZeros?: () => number;
                                ctz?: () => number;
                                notEquals?: (other: string | number | import("long").default) => boolean;
                                neq?: (other: string | number | import("long").default) => boolean;
                                ne?: (other: string | number | import("long").default) => boolean;
                                or?: (other: string | number | import("long").default) => import("long").default;
                                shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                                shl?: (numBits: number | import("long").default) => import("long").default;
                                shiftRight?: (numBits: number | import("long").default) => import("long").default;
                                shr?: (numBits: number | import("long").default) => import("long").default;
                                shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                                shru?: (numBits: number | import("long").default) => import("long").default;
                                shr_u?: (numBits: number | import("long").default) => import("long").default;
                                rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                                rotl?: (numBits: number | import("long").default) => import("long").default;
                                rotateRight?: (numBits: number | import("long").default) => import("long").default;
                                rotr?: (numBits: number | import("long").default) => import("long").default;
                                subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                                sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                                toInt?: () => number;
                                toNumber?: () => number;
                                toBytes?: (le?: boolean) => number[];
                                toBytesLE?: () => number[];
                                toBytesBE?: () => number[];
                                toSigned?: () => import("long").default;
                                toString?: (radix?: number) => string;
                                toUnsigned?: () => import("long").default;
                                xor?: (other: string | number | import("long").default) => import("long").default;
                            };
                            nanos?: number;
                        };
                        timeoutTimestamp?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        requestSent?: boolean;
                        submissionHeight?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                    }[];
                }): _119.GenesisState;
            };
        };
    }
    namespace mint {
        const v1beta1: {
            QueryClientImpl: typeof _257.QueryClientImpl;
            createRpcQueryExtension: (base: import("@cosmjs/stargate").QueryClient) => {
                params(request?: _124.QueryParamsRequest): Promise<_124.QueryParamsResponse>;
                epochProvisions(request?: _124.QueryEpochProvisionsRequest): Promise<_124.QueryEpochProvisionsResponse>;
            };
            LCDQueryClient: typeof _246.LCDQueryClient;
            QueryParamsRequest: {
                encode(_: _124.QueryParamsRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _124.QueryParamsRequest;
                fromPartial(_: {}): _124.QueryParamsRequest;
            };
            QueryParamsResponse: {
                encode(message: _124.QueryParamsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _124.QueryParamsResponse;
                fromPartial(object: {
                    params?: {
                        mintDenom?: string;
                        genesisEpochProvisions?: string;
                        epochIdentifier?: string;
                        reductionPeriodInEpochs?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        reductionFactor?: string;
                        distributionProportions?: {
                            staking?: string;
                            communityPoolGrowth?: string;
                            communityPoolSecurityBudget?: string;
                            strategicReserve?: string;
                        };
                        mintingRewardsDistributionStartEpoch?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                    };
                }): _124.QueryParamsResponse;
            };
            QueryEpochProvisionsRequest: {
                encode(_: _124.QueryEpochProvisionsRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _124.QueryEpochProvisionsRequest;
                fromPartial(_: {}): _124.QueryEpochProvisionsRequest;
            };
            QueryEpochProvisionsResponse: {
                encode(message: _124.QueryEpochProvisionsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _124.QueryEpochProvisionsResponse;
                fromPartial(object: {
                    epochProvisions?: Uint8Array;
                }): _124.QueryEpochProvisionsResponse;
            };
            Minter: {
                encode(message: _123.Minter, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _123.Minter;
                fromPartial(object: {
                    epochProvisions?: string;
                }): _123.Minter;
            };
            DistributionProportions: {
                encode(message: _123.DistributionProportions, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _123.DistributionProportions;
                fromPartial(object: {
                    staking?: string;
                    communityPoolGrowth?: string;
                    communityPoolSecurityBudget?: string;
                    strategicReserve?: string;
                }): _123.DistributionProportions;
            };
            Params: {
                encode(message: _123.Params, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _123.Params;
                fromPartial(object: {
                    mintDenom?: string;
                    genesisEpochProvisions?: string;
                    epochIdentifier?: string;
                    reductionPeriodInEpochs?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    reductionFactor?: string;
                    distributionProportions?: {
                        staking?: string;
                        communityPoolGrowth?: string;
                        communityPoolSecurityBudget?: string;
                        strategicReserve?: string;
                    };
                    mintingRewardsDistributionStartEpoch?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                }): _123.Params;
            };
            GenesisState: {
                encode(message: _122.GenesisState, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _122.GenesisState;
                fromPartial(object: {
                    minter?: {
                        epochProvisions?: string;
                    };
                    params?: {
                        mintDenom?: string;
                        genesisEpochProvisions?: string;
                        epochIdentifier?: string;
                        reductionPeriodInEpochs?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        reductionFactor?: string;
                        distributionProportions?: {
                            staking?: string;
                            communityPoolGrowth?: string;
                            communityPoolSecurityBudget?: string;
                            strategicReserve?: string;
                        };
                        mintingRewardsDistributionStartEpoch?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                    };
                    reductionStartedEpoch?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                }): _122.GenesisState;
            };
        };
    }
    const records: {
        QueryClientImpl: typeof _258.QueryClientImpl;
        createRpcQueryExtension: (base: import("@cosmjs/stargate").QueryClient) => {
            params(request?: _128.QueryParamsRequest): Promise<_128.QueryParamsResponse>;
            userRedemptionRecord(request: _128.QueryGetUserRedemptionRecordRequest): Promise<_128.QueryGetUserRedemptionRecordResponse>;
            userRedemptionRecordAll(request?: _128.QueryAllUserRedemptionRecordRequest): Promise<_128.QueryAllUserRedemptionRecordResponse>;
            userRedemptionRecordForUser(request: _128.QueryAllUserRedemptionRecordForUserRequest): Promise<_128.QueryAllUserRedemptionRecordForUserResponse>;
            epochUnbondingRecord(request: _128.QueryGetEpochUnbondingRecordRequest): Promise<_128.QueryGetEpochUnbondingRecordResponse>;
            epochUnbondingRecordAll(request?: _128.QueryAllEpochUnbondingRecordRequest): Promise<_128.QueryAllEpochUnbondingRecordResponse>;
            depositRecord(request: _128.QueryGetDepositRecordRequest): Promise<_128.QueryGetDepositRecordResponse>;
            depositRecordAll(request?: _128.QueryAllDepositRecordRequest): Promise<_128.QueryAllDepositRecordResponse>;
            depositRecordByHost(request: _128.QueryDepositRecordByHostRequest): Promise<_128.QueryDepositRecordByHostResponse>;
            lSMDeposit(request: _128.QueryLSMDepositRequest): Promise<_128.QueryLSMDepositResponse>;
            lSMDeposits(request: _128.QueryLSMDepositsRequest): Promise<_128.QueryLSMDepositsResponse>;
        };
        LCDQueryClient: typeof _247.LCDQueryClient;
        depositRecord_StatusFromJSON(object: any): _129.DepositRecord_Status;
        depositRecord_StatusToJSON(object: _129.DepositRecord_Status): string;
        depositRecord_SourceFromJSON(object: any): _129.DepositRecord_Source;
        depositRecord_SourceToJSON(object: _129.DepositRecord_Source): string;
        hostZoneUnbonding_StatusFromJSON(object: any): _129.HostZoneUnbonding_Status;
        hostZoneUnbonding_StatusToJSON(object: _129.HostZoneUnbonding_Status): string;
        lSMTokenDeposit_StatusFromJSON(object: any): _129.LSMTokenDeposit_Status;
        lSMTokenDeposit_StatusToJSON(object: _129.LSMTokenDeposit_Status): string;
        DepositRecord_Status: typeof _129.DepositRecord_Status;
        DepositRecord_StatusSDKType: typeof _129.DepositRecord_StatusSDKType;
        DepositRecord_Source: typeof _129.DepositRecord_Source;
        DepositRecord_SourceSDKType: typeof _129.DepositRecord_SourceSDKType;
        HostZoneUnbonding_Status: typeof _129.HostZoneUnbonding_Status;
        HostZoneUnbonding_StatusSDKType: typeof _129.HostZoneUnbonding_StatusSDKType;
        LSMTokenDeposit_Status: typeof _129.LSMTokenDeposit_Status;
        LSMTokenDeposit_StatusSDKType: typeof _129.LSMTokenDeposit_StatusSDKType;
        UserRedemptionRecord: {
            encode(message: _129.UserRedemptionRecord, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _129.UserRedemptionRecord;
            fromPartial(object: {
                id?: string;
                receiver?: string;
                nativeTokenAmount?: string;
                denom?: string;
                hostZoneId?: string;
                epochNumber?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                claimIsPending?: boolean;
                stTokenAmount?: string;
            }): _129.UserRedemptionRecord;
        };
        DepositRecord: {
            encode(message: _129.DepositRecord, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _129.DepositRecord;
            fromPartial(object: {
                id?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                amount?: string;
                denom?: string;
                hostZoneId?: string;
                status?: _129.DepositRecord_Status;
                depositEpochNumber?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                source?: _129.DepositRecord_Source;
            }): _129.DepositRecord;
        };
        HostZoneUnbonding: {
            encode(message: _129.HostZoneUnbonding, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _129.HostZoneUnbonding;
            fromPartial(object: {
                stTokenAmount?: string;
                nativeTokenAmount?: string;
                denom?: string;
                hostZoneId?: string;
                unbondingTime?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                status?: _129.HostZoneUnbonding_Status;
                userRedemptionRecords?: string[];
            }): _129.HostZoneUnbonding;
        };
        EpochUnbondingRecord: {
            encode(message: _129.EpochUnbondingRecord, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _129.EpochUnbondingRecord;
            fromPartial(object: {
                epochNumber?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                hostZoneUnbondings?: {
                    stTokenAmount?: string;
                    nativeTokenAmount?: string;
                    denom?: string;
                    hostZoneId?: string;
                    unbondingTime?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    status?: _129.HostZoneUnbonding_Status;
                    userRedemptionRecords?: string[];
                }[];
            }): _129.EpochUnbondingRecord;
        };
        LSMTokenDeposit: {
            encode(message: _129.LSMTokenDeposit, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _129.LSMTokenDeposit;
            fromPartial(object: {
                depositId?: string;
                chainId?: string;
                denom?: string;
                ibcDenom?: string;
                stakerAddress?: string;
                validatorAddress?: string;
                amount?: string;
                stToken?: {
                    denom?: string;
                    amount?: string;
                };
                status?: _129.LSMTokenDeposit_Status;
            }): _129.LSMTokenDeposit;
        };
        QueryParamsRequest: {
            encode(_: _128.QueryParamsRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _128.QueryParamsRequest;
            fromPartial(_: {}): _128.QueryParamsRequest;
        };
        QueryParamsResponse: {
            encode(message: _128.QueryParamsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _128.QueryParamsResponse;
            fromPartial(object: {
                params?: {};
            }): _128.QueryParamsResponse;
        };
        QueryGetDepositRecordRequest: {
            encode(message: _128.QueryGetDepositRecordRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _128.QueryGetDepositRecordRequest;
            fromPartial(object: {
                id?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
            }): _128.QueryGetDepositRecordRequest;
        };
        QueryGetDepositRecordResponse: {
            encode(message: _128.QueryGetDepositRecordResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _128.QueryGetDepositRecordResponse;
            fromPartial(object: {
                depositRecord?: {
                    id?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    amount?: string;
                    denom?: string;
                    hostZoneId?: string;
                    status?: _129.DepositRecord_Status;
                    depositEpochNumber?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    source?: _129.DepositRecord_Source;
                };
            }): _128.QueryGetDepositRecordResponse;
        };
        QueryAllDepositRecordRequest: {
            encode(message: _128.QueryAllDepositRecordRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _128.QueryAllDepositRecordRequest;
            fromPartial(object: {
                pagination?: {
                    key?: Uint8Array;
                    offset?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    limit?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    countTotal?: boolean;
                    reverse?: boolean;
                };
            }): _128.QueryAllDepositRecordRequest;
        };
        QueryAllDepositRecordResponse: {
            encode(message: _128.QueryAllDepositRecordResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _128.QueryAllDepositRecordResponse;
            fromPartial(object: {
                depositRecord?: {
                    id?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    amount?: string;
                    denom?: string;
                    hostZoneId?: string;
                    status?: _129.DepositRecord_Status;
                    depositEpochNumber?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    source?: _129.DepositRecord_Source;
                }[];
                pagination?: {
                    nextKey?: Uint8Array;
                    total?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                };
            }): _128.QueryAllDepositRecordResponse;
        };
        QueryDepositRecordByHostRequest: {
            encode(message: _128.QueryDepositRecordByHostRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _128.QueryDepositRecordByHostRequest;
            fromPartial(object: {
                hostZoneId?: string;
            }): _128.QueryDepositRecordByHostRequest;
        };
        QueryDepositRecordByHostResponse: {
            encode(message: _128.QueryDepositRecordByHostResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _128.QueryDepositRecordByHostResponse;
            fromPartial(object: {
                depositRecord?: {
                    id?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    amount?: string;
                    denom?: string;
                    hostZoneId?: string;
                    status?: _129.DepositRecord_Status;
                    depositEpochNumber?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    source?: _129.DepositRecord_Source;
                }[];
            }): _128.QueryDepositRecordByHostResponse;
        };
        QueryGetUserRedemptionRecordRequest: {
            encode(message: _128.QueryGetUserRedemptionRecordRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _128.QueryGetUserRedemptionRecordRequest;
            fromPartial(object: {
                id?: string;
            }): _128.QueryGetUserRedemptionRecordRequest;
        };
        QueryGetUserRedemptionRecordResponse: {
            encode(message: _128.QueryGetUserRedemptionRecordResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _128.QueryGetUserRedemptionRecordResponse;
            fromPartial(object: {
                userRedemptionRecord?: {
                    id?: string;
                    receiver?: string;
                    nativeTokenAmount?: string;
                    denom?: string;
                    hostZoneId?: string;
                    epochNumber?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    claimIsPending?: boolean;
                    stTokenAmount?: string;
                };
            }): _128.QueryGetUserRedemptionRecordResponse;
        };
        QueryAllUserRedemptionRecordRequest: {
            encode(message: _128.QueryAllUserRedemptionRecordRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _128.QueryAllUserRedemptionRecordRequest;
            fromPartial(object: {
                pagination?: {
                    key?: Uint8Array;
                    offset?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    limit?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    countTotal?: boolean;
                    reverse?: boolean;
                };
            }): _128.QueryAllUserRedemptionRecordRequest;
        };
        QueryAllUserRedemptionRecordResponse: {
            encode(message: _128.QueryAllUserRedemptionRecordResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _128.QueryAllUserRedemptionRecordResponse;
            fromPartial(object: {
                userRedemptionRecord?: {
                    id?: string;
                    receiver?: string;
                    nativeTokenAmount?: string;
                    denom?: string;
                    hostZoneId?: string;
                    epochNumber?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    claimIsPending?: boolean;
                    stTokenAmount?: string;
                }[];
                pagination?: {
                    nextKey?: Uint8Array;
                    total?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                };
            }): _128.QueryAllUserRedemptionRecordResponse;
        };
        QueryAllUserRedemptionRecordForUserRequest: {
            encode(message: _128.QueryAllUserRedemptionRecordForUserRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _128.QueryAllUserRedemptionRecordForUserRequest;
            fromPartial(object: {
                chainId?: string;
                day?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                address?: string;
                limit?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                pagination?: {
                    key?: Uint8Array;
                    offset?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    limit?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    countTotal?: boolean;
                    reverse?: boolean;
                };
            }): _128.QueryAllUserRedemptionRecordForUserRequest;
        };
        QueryAllUserRedemptionRecordForUserResponse: {
            encode(message: _128.QueryAllUserRedemptionRecordForUserResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _128.QueryAllUserRedemptionRecordForUserResponse;
            fromPartial(object: {
                userRedemptionRecord?: {
                    id?: string;
                    receiver?: string;
                    nativeTokenAmount?: string;
                    denom?: string;
                    hostZoneId?: string;
                    epochNumber?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    claimIsPending?: boolean;
                    stTokenAmount?: string;
                }[];
                pagination?: {
                    nextKey?: Uint8Array;
                    total?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                };
            }): _128.QueryAllUserRedemptionRecordForUserResponse;
        };
        QueryGetEpochUnbondingRecordRequest: {
            encode(message: _128.QueryGetEpochUnbondingRecordRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _128.QueryGetEpochUnbondingRecordRequest;
            fromPartial(object: {
                epochNumber?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
            }): _128.QueryGetEpochUnbondingRecordRequest;
        };
        QueryGetEpochUnbondingRecordResponse: {
            encode(message: _128.QueryGetEpochUnbondingRecordResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _128.QueryGetEpochUnbondingRecordResponse;
            fromPartial(object: {
                epochUnbondingRecord?: {
                    epochNumber?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    hostZoneUnbondings?: {
                        stTokenAmount?: string;
                        nativeTokenAmount?: string;
                        denom?: string;
                        hostZoneId?: string;
                        unbondingTime?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        status?: _129.HostZoneUnbonding_Status;
                        userRedemptionRecords?: string[];
                    }[];
                };
            }): _128.QueryGetEpochUnbondingRecordResponse;
        };
        QueryAllEpochUnbondingRecordRequest: {
            encode(message: _128.QueryAllEpochUnbondingRecordRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _128.QueryAllEpochUnbondingRecordRequest;
            fromPartial(object: {
                pagination?: {
                    key?: Uint8Array;
                    offset?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    limit?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    countTotal?: boolean;
                    reverse?: boolean;
                };
            }): _128.QueryAllEpochUnbondingRecordRequest;
        };
        QueryAllEpochUnbondingRecordResponse: {
            encode(message: _128.QueryAllEpochUnbondingRecordResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _128.QueryAllEpochUnbondingRecordResponse;
            fromPartial(object: {
                epochUnbondingRecord?: {
                    epochNumber?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    hostZoneUnbondings?: {
                        stTokenAmount?: string;
                        nativeTokenAmount?: string;
                        denom?: string;
                        hostZoneId?: string;
                        unbondingTime?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        status?: _129.HostZoneUnbonding_Status;
                        userRedemptionRecords?: string[];
                    }[];
                }[];
                pagination?: {
                    nextKey?: Uint8Array;
                    total?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                };
            }): _128.QueryAllEpochUnbondingRecordResponse;
        };
        QueryLSMDepositRequest: {
            encode(message: _128.QueryLSMDepositRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _128.QueryLSMDepositRequest;
            fromPartial(object: {
                chainId?: string;
                denom?: string;
            }): _128.QueryLSMDepositRequest;
        };
        QueryLSMDepositResponse: {
            encode(message: _128.QueryLSMDepositResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _128.QueryLSMDepositResponse;
            fromPartial(object: {
                deposit?: {
                    depositId?: string;
                    chainId?: string;
                    denom?: string;
                    ibcDenom?: string;
                    stakerAddress?: string;
                    validatorAddress?: string;
                    amount?: string;
                    stToken?: {
                        denom?: string;
                        amount?: string;
                    };
                    status?: _129.LSMTokenDeposit_Status;
                };
            }): _128.QueryLSMDepositResponse;
        };
        QueryLSMDepositsRequest: {
            encode(message: _128.QueryLSMDepositsRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _128.QueryLSMDepositsRequest;
            fromPartial(object: {
                chainId?: string;
                validatorAddress?: string;
                status?: string;
            }): _128.QueryLSMDepositsRequest;
        };
        QueryLSMDepositsResponse: {
            encode(message: _128.QueryLSMDepositsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _128.QueryLSMDepositsResponse;
            fromPartial(object: {
                deposits?: {
                    depositId?: string;
                    chainId?: string;
                    denom?: string;
                    ibcDenom?: string;
                    stakerAddress?: string;
                    validatorAddress?: string;
                    amount?: string;
                    stToken?: {
                        denom?: string;
                        amount?: string;
                    };
                    status?: _129.LSMTokenDeposit_Status;
                }[];
            }): _128.QueryLSMDepositsResponse;
        };
        Params: {
            encode(_: _127.Params, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _127.Params;
            fromPartial(_: {}): _127.Params;
        };
        GenesisState: {
            encode(message: _126.GenesisState, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _126.GenesisState;
            fromPartial(object: {
                params?: {};
                portId?: string;
                userRedemptionRecordList?: {
                    id?: string;
                    receiver?: string;
                    nativeTokenAmount?: string;
                    denom?: string;
                    hostZoneId?: string;
                    epochNumber?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    claimIsPending?: boolean;
                    stTokenAmount?: string;
                }[];
                userRedemptionRecordCount?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                epochUnbondingRecordList?: {
                    epochNumber?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    hostZoneUnbondings?: {
                        stTokenAmount?: string;
                        nativeTokenAmount?: string;
                        denom?: string;
                        hostZoneId?: string;
                        unbondingTime?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        status?: _129.HostZoneUnbonding_Status;
                        userRedemptionRecords?: string[];
                    }[];
                }[];
                depositRecordList?: {
                    id?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    amount?: string;
                    denom?: string;
                    hostZoneId?: string;
                    status?: _129.DepositRecord_Status;
                    depositEpochNumber?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    source?: _129.DepositRecord_Source;
                }[];
                depositRecordCount?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                lsmTokenDepositList?: {
                    depositId?: string;
                    chainId?: string;
                    denom?: string;
                    ibcDenom?: string;
                    stakerAddress?: string;
                    validatorAddress?: string;
                    amount?: string;
                    stToken?: {
                        denom?: string;
                        amount?: string;
                    };
                    status?: _129.LSMTokenDeposit_Status;
                }[];
            }): _126.GenesisState;
        };
        TransferCallback: {
            encode(message: _125.TransferCallback, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _125.TransferCallback;
            fromPartial(object: {
                depositRecordId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
            }): _125.TransferCallback;
        };
        TransferLSMTokenCallback: {
            encode(message: _125.TransferLSMTokenCallback, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _125.TransferLSMTokenCallback;
            fromPartial(object: {
                deposit?: {
                    depositId?: string;
                    chainId?: string;
                    denom?: string;
                    ibcDenom?: string;
                    stakerAddress?: string;
                    validatorAddress?: string;
                    amount?: string;
                    stToken?: {
                        denom?: string;
                        amount?: string;
                    };
                    status?: _129.LSMTokenDeposit_Status;
                };
            }): _125.TransferLSMTokenCallback;
        };
    };
    const stakedym: {
        MsgClientImpl: typeof _266.MsgClientImpl;
        QueryClientImpl: typeof _259.QueryClientImpl;
        createRpcQueryExtension: (base: import("@cosmjs/stargate").QueryClient) => {
            hostZone(request?: _131.QueryHostZoneRequest): Promise<_131.QueryHostZoneResponse>;
            delegationRecords(request: _131.QueryDelegationRecordsRequest): Promise<_131.QueryDelegationRecordsResponse>;
            unbondingRecords(request: _131.QueryUnbondingRecordsRequest): Promise<_131.QueryUnbondingRecordsResponse>;
            redemptionRecord(request: _131.QueryRedemptionRecordRequest): Promise<_131.QueryRedemptionRecordResponse>;
            redemptionRecords(request: _131.QueryRedemptionRecordsRequest): Promise<_131.QueryRedemptionRecordsResponse>;
            slashRecords(request?: _131.QuerySlashRecordsRequest): Promise<_131.QuerySlashRecordsResponse>;
        };
        LCDQueryClient: typeof _248.LCDQueryClient;
        registry: readonly [string, import("@cosmjs/proto-signing").GeneratedType][];
        load: (protoRegistry: import("@cosmjs/proto-signing").Registry) => void;
        MessageComposer: {
            encoded: {
                liquidStake(value: _133.MsgLiquidStake): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                redeemStake(value: _133.MsgRedeemStake): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                confirmDelegation(value: _133.MsgConfirmDelegation): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                confirmUndelegation(value: _133.MsgConfirmUndelegation): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                confirmUnbondedTokenSweep(value: _133.MsgConfirmUnbondedTokenSweep): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                adjustDelegatedBalance(value: _133.MsgAdjustDelegatedBalance): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                updateInnerRedemptionRateBounds(value: _133.MsgUpdateInnerRedemptionRateBounds): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                resumeHostZone(value: _133.MsgResumeHostZone): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                refreshRedemptionRate(value: _133.MsgRefreshRedemptionRate): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                overwriteDelegationRecord(value: _133.MsgOverwriteDelegationRecord): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                overwriteUnbondingRecord(value: _133.MsgOverwriteUnbondingRecord): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                overwriteRedemptionRecord(value: _133.MsgOverwriteRedemptionRecord): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                setOperatorAddress(value: _133.MsgSetOperatorAddress): {
                    typeUrl: string;
                    value: Uint8Array;
                };
            };
            withTypeUrl: {
                liquidStake(value: _133.MsgLiquidStake): {
                    typeUrl: string;
                    value: _133.MsgLiquidStake;
                };
                redeemStake(value: _133.MsgRedeemStake): {
                    typeUrl: string;
                    value: _133.MsgRedeemStake;
                };
                confirmDelegation(value: _133.MsgConfirmDelegation): {
                    typeUrl: string;
                    value: _133.MsgConfirmDelegation;
                };
                confirmUndelegation(value: _133.MsgConfirmUndelegation): {
                    typeUrl: string;
                    value: _133.MsgConfirmUndelegation;
                };
                confirmUnbondedTokenSweep(value: _133.MsgConfirmUnbondedTokenSweep): {
                    typeUrl: string;
                    value: _133.MsgConfirmUnbondedTokenSweep;
                };
                adjustDelegatedBalance(value: _133.MsgAdjustDelegatedBalance): {
                    typeUrl: string;
                    value: _133.MsgAdjustDelegatedBalance;
                };
                updateInnerRedemptionRateBounds(value: _133.MsgUpdateInnerRedemptionRateBounds): {
                    typeUrl: string;
                    value: _133.MsgUpdateInnerRedemptionRateBounds;
                };
                resumeHostZone(value: _133.MsgResumeHostZone): {
                    typeUrl: string;
                    value: _133.MsgResumeHostZone;
                };
                refreshRedemptionRate(value: _133.MsgRefreshRedemptionRate): {
                    typeUrl: string;
                    value: _133.MsgRefreshRedemptionRate;
                };
                overwriteDelegationRecord(value: _133.MsgOverwriteDelegationRecord): {
                    typeUrl: string;
                    value: _133.MsgOverwriteDelegationRecord;
                };
                overwriteUnbondingRecord(value: _133.MsgOverwriteUnbondingRecord): {
                    typeUrl: string;
                    value: _133.MsgOverwriteUnbondingRecord;
                };
                overwriteRedemptionRecord(value: _133.MsgOverwriteRedemptionRecord): {
                    typeUrl: string;
                    value: _133.MsgOverwriteRedemptionRecord;
                };
                setOperatorAddress(value: _133.MsgSetOperatorAddress): {
                    typeUrl: string;
                    value: _133.MsgSetOperatorAddress;
                };
            };
            fromPartial: {
                liquidStake(value: _133.MsgLiquidStake): {
                    typeUrl: string;
                    value: _133.MsgLiquidStake;
                };
                redeemStake(value: _133.MsgRedeemStake): {
                    typeUrl: string;
                    value: _133.MsgRedeemStake;
                };
                confirmDelegation(value: _133.MsgConfirmDelegation): {
                    typeUrl: string;
                    value: _133.MsgConfirmDelegation;
                };
                confirmUndelegation(value: _133.MsgConfirmUndelegation): {
                    typeUrl: string;
                    value: _133.MsgConfirmUndelegation;
                };
                confirmUnbondedTokenSweep(value: _133.MsgConfirmUnbondedTokenSweep): {
                    typeUrl: string;
                    value: _133.MsgConfirmUnbondedTokenSweep;
                };
                adjustDelegatedBalance(value: _133.MsgAdjustDelegatedBalance): {
                    typeUrl: string;
                    value: _133.MsgAdjustDelegatedBalance;
                };
                updateInnerRedemptionRateBounds(value: _133.MsgUpdateInnerRedemptionRateBounds): {
                    typeUrl: string;
                    value: _133.MsgUpdateInnerRedemptionRateBounds;
                };
                resumeHostZone(value: _133.MsgResumeHostZone): {
                    typeUrl: string;
                    value: _133.MsgResumeHostZone;
                };
                refreshRedemptionRate(value: _133.MsgRefreshRedemptionRate): {
                    typeUrl: string;
                    value: _133.MsgRefreshRedemptionRate;
                };
                overwriteDelegationRecord(value: _133.MsgOverwriteDelegationRecord): {
                    typeUrl: string;
                    value: _133.MsgOverwriteDelegationRecord;
                };
                overwriteUnbondingRecord(value: _133.MsgOverwriteUnbondingRecord): {
                    typeUrl: string;
                    value: _133.MsgOverwriteUnbondingRecord;
                };
                overwriteRedemptionRecord(value: _133.MsgOverwriteRedemptionRecord): {
                    typeUrl: string;
                    value: _133.MsgOverwriteRedemptionRecord;
                };
                setOperatorAddress(value: _133.MsgSetOperatorAddress): {
                    typeUrl: string;
                    value: _133.MsgSetOperatorAddress;
                };
            };
        };
        AminoConverter: {
            "/stride.stakedym.MsgLiquidStake": {
                aminoType: string;
                toAmino: ({ staker, nativeAmount }: _133.MsgLiquidStake) => {
                    staker: string;
                    native_amount: string;
                };
                fromAmino: ({ staker, native_amount }: {
                    staker: string;
                    native_amount: string;
                }) => _133.MsgLiquidStake;
            };
            "/stride.stakedym.MsgRedeemStake": {
                aminoType: string;
                toAmino: ({ redeemer, stTokenAmount }: _133.MsgRedeemStake) => {
                    redeemer: string;
                    st_token_amount: string;
                };
                fromAmino: ({ redeemer, st_token_amount }: {
                    redeemer: string;
                    st_token_amount: string;
                }) => _133.MsgRedeemStake;
            };
            "/stride.stakedym.MsgConfirmDelegation": {
                aminoType: string;
                toAmino: ({ operator, recordId, txHash }: _133.MsgConfirmDelegation) => {
                    operator: string;
                    record_id: string;
                    tx_hash: string;
                };
                fromAmino: ({ operator, record_id, tx_hash }: {
                    operator: string;
                    record_id: string;
                    tx_hash: string;
                }) => _133.MsgConfirmDelegation;
            };
            "/stride.stakedym.MsgConfirmUndelegation": {
                aminoType: string;
                toAmino: ({ operator, recordId, txHash }: _133.MsgConfirmUndelegation) => {
                    operator: string;
                    record_id: string;
                    tx_hash: string;
                };
                fromAmino: ({ operator, record_id, tx_hash }: {
                    operator: string;
                    record_id: string;
                    tx_hash: string;
                }) => _133.MsgConfirmUndelegation;
            };
            "/stride.stakedym.MsgConfirmUnbondedTokenSweep": {
                aminoType: string;
                toAmino: ({ operator, recordId, txHash }: _133.MsgConfirmUnbondedTokenSweep) => {
                    operator: string;
                    record_id: string;
                    tx_hash: string;
                };
                fromAmino: ({ operator, record_id, tx_hash }: {
                    operator: string;
                    record_id: string;
                    tx_hash: string;
                }) => _133.MsgConfirmUnbondedTokenSweep;
            };
            "/stride.stakedym.MsgAdjustDelegatedBalance": {
                aminoType: string;
                toAmino: ({ operator, delegationOffset, validatorAddress }: _133.MsgAdjustDelegatedBalance) => {
                    operator: string;
                    delegation_offset: string;
                    validator_address: string;
                };
                fromAmino: ({ operator, delegation_offset, validator_address }: {
                    operator: string;
                    delegation_offset: string;
                    validator_address: string;
                }) => _133.MsgAdjustDelegatedBalance;
            };
            "/stride.stakedym.MsgUpdateInnerRedemptionRateBounds": {
                aminoType: string;
                toAmino: ({ creator, minInnerRedemptionRate, maxInnerRedemptionRate }: _133.MsgUpdateInnerRedemptionRateBounds) => {
                    creator: string;
                    min_inner_redemption_rate: string;
                    max_inner_redemption_rate: string;
                };
                fromAmino: ({ creator, min_inner_redemption_rate, max_inner_redemption_rate }: {
                    creator: string;
                    min_inner_redemption_rate: string;
                    max_inner_redemption_rate: string;
                }) => _133.MsgUpdateInnerRedemptionRateBounds;
            };
            "/stride.stakedym.MsgResumeHostZone": {
                aminoType: string;
                toAmino: ({ creator }: _133.MsgResumeHostZone) => {
                    creator: string;
                };
                fromAmino: ({ creator }: {
                    creator: string;
                }) => _133.MsgResumeHostZone;
            };
            "/stride.stakedym.MsgRefreshRedemptionRate": {
                aminoType: string;
                toAmino: ({ creator }: _133.MsgRefreshRedemptionRate) => {
                    creator: string;
                };
                fromAmino: ({ creator }: {
                    creator: string;
                }) => _133.MsgRefreshRedemptionRate;
            };
            "/stride.stakedym.MsgOverwriteDelegationRecord": {
                aminoType: string;
                toAmino: ({ creator, delegationRecord }: _133.MsgOverwriteDelegationRecord) => {
                    creator: string;
                    delegation_record: {
                        id: string;
                        native_amount: string;
                        status: number;
                        tx_hash: string;
                    };
                };
                fromAmino: ({ creator, delegation_record }: {
                    creator: string;
                    delegation_record: {
                        id: string;
                        native_amount: string;
                        status: number;
                        tx_hash: string;
                    };
                }) => _133.MsgOverwriteDelegationRecord;
            };
            "/stride.stakedym.MsgOverwriteUnbondingRecord": {
                aminoType: string;
                toAmino: ({ creator, unbondingRecord }: _133.MsgOverwriteUnbondingRecord) => {
                    creator: string;
                    unbonding_record: {
                        id: string;
                        status: number;
                        st_token_amount: string;
                        native_amount: string;
                        unbonding_completion_time_seconds: string;
                        undelegation_tx_hash: string;
                        unbonded_token_sweep_tx_hash: string;
                    };
                };
                fromAmino: ({ creator, unbonding_record }: {
                    creator: string;
                    unbonding_record: {
                        id: string;
                        status: number;
                        st_token_amount: string;
                        native_amount: string;
                        unbonding_completion_time_seconds: string;
                        undelegation_tx_hash: string;
                        unbonded_token_sweep_tx_hash: string;
                    };
                }) => _133.MsgOverwriteUnbondingRecord;
            };
            "/stride.stakedym.MsgOverwriteRedemptionRecord": {
                aminoType: string;
                toAmino: ({ creator, redemptionRecord }: _133.MsgOverwriteRedemptionRecord) => {
                    creator: string;
                    redemption_record: {
                        unbonding_record_id: string;
                        redeemer: string;
                        st_token_amount: string;
                        native_amount: string;
                    };
                };
                fromAmino: ({ creator, redemption_record }: {
                    creator: string;
                    redemption_record: {
                        unbonding_record_id: string;
                        redeemer: string;
                        st_token_amount: string;
                        native_amount: string;
                    };
                }) => _133.MsgOverwriteRedemptionRecord;
            };
            "/stride.stakedym.MsgSetOperatorAddress": {
                aminoType: string;
                toAmino: ({ signer, operator }: _133.MsgSetOperatorAddress) => {
                    signer: string;
                    operator: string;
                };
                fromAmino: ({ signer, operator }: {
                    signer: string;
                    operator: string;
                }) => _133.MsgSetOperatorAddress;
            };
        };
        overwritableRecordTypeFromJSON(object: any): _133.OverwritableRecordType;
        overwritableRecordTypeToJSON(object: _133.OverwritableRecordType): string;
        OverwritableRecordType: typeof _133.OverwritableRecordType;
        OverwritableRecordTypeSDKType: typeof _133.OverwritableRecordTypeSDKType;
        MsgLiquidStake: {
            encode(message: _133.MsgLiquidStake, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _133.MsgLiquidStake;
            fromPartial(object: {
                staker?: string;
                nativeAmount?: string;
            }): _133.MsgLiquidStake;
        };
        MsgLiquidStakeResponse: {
            encode(message: _133.MsgLiquidStakeResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _133.MsgLiquidStakeResponse;
            fromPartial(object: {
                stToken?: {
                    denom?: string;
                    amount?: string;
                };
            }): _133.MsgLiquidStakeResponse;
        };
        MsgRedeemStake: {
            encode(message: _133.MsgRedeemStake, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _133.MsgRedeemStake;
            fromPartial(object: {
                redeemer?: string;
                stTokenAmount?: string;
            }): _133.MsgRedeemStake;
        };
        MsgRedeemStakeResponse: {
            encode(message: _133.MsgRedeemStakeResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _133.MsgRedeemStakeResponse;
            fromPartial(object: {
                nativeToken?: {
                    denom?: string;
                    amount?: string;
                };
            }): _133.MsgRedeemStakeResponse;
        };
        MsgConfirmDelegation: {
            encode(message: _133.MsgConfirmDelegation, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _133.MsgConfirmDelegation;
            fromPartial(object: {
                operator?: string;
                recordId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                txHash?: string;
            }): _133.MsgConfirmDelegation;
        };
        MsgConfirmDelegationResponse: {
            encode(_: _133.MsgConfirmDelegationResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _133.MsgConfirmDelegationResponse;
            fromPartial(_: {}): _133.MsgConfirmDelegationResponse;
        };
        MsgConfirmUndelegation: {
            encode(message: _133.MsgConfirmUndelegation, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _133.MsgConfirmUndelegation;
            fromPartial(object: {
                operator?: string;
                recordId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                txHash?: string;
            }): _133.MsgConfirmUndelegation;
        };
        MsgConfirmUndelegationResponse: {
            encode(_: _133.MsgConfirmUndelegationResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _133.MsgConfirmUndelegationResponse;
            fromPartial(_: {}): _133.MsgConfirmUndelegationResponse;
        };
        MsgConfirmUnbondedTokenSweep: {
            encode(message: _133.MsgConfirmUnbondedTokenSweep, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _133.MsgConfirmUnbondedTokenSweep;
            fromPartial(object: {
                operator?: string;
                recordId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                txHash?: string;
            }): _133.MsgConfirmUnbondedTokenSweep;
        };
        MsgConfirmUnbondedTokenSweepResponse: {
            encode(_: _133.MsgConfirmUnbondedTokenSweepResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _133.MsgConfirmUnbondedTokenSweepResponse;
            fromPartial(_: {}): _133.MsgConfirmUnbondedTokenSweepResponse;
        };
        MsgAdjustDelegatedBalance: {
            encode(message: _133.MsgAdjustDelegatedBalance, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _133.MsgAdjustDelegatedBalance;
            fromPartial(object: {
                operator?: string;
                delegationOffset?: string;
                validatorAddress?: string;
            }): _133.MsgAdjustDelegatedBalance;
        };
        MsgAdjustDelegatedBalanceResponse: {
            encode(_: _133.MsgAdjustDelegatedBalanceResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _133.MsgAdjustDelegatedBalanceResponse;
            fromPartial(_: {}): _133.MsgAdjustDelegatedBalanceResponse;
        };
        MsgUpdateInnerRedemptionRateBounds: {
            encode(message: _133.MsgUpdateInnerRedemptionRateBounds, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _133.MsgUpdateInnerRedemptionRateBounds;
            fromPartial(object: {
                creator?: string;
                minInnerRedemptionRate?: string;
                maxInnerRedemptionRate?: string;
            }): _133.MsgUpdateInnerRedemptionRateBounds;
        };
        MsgUpdateInnerRedemptionRateBoundsResponse: {
            encode(_: _133.MsgUpdateInnerRedemptionRateBoundsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _133.MsgUpdateInnerRedemptionRateBoundsResponse;
            fromPartial(_: {}): _133.MsgUpdateInnerRedemptionRateBoundsResponse;
        };
        MsgResumeHostZone: {
            encode(message: _133.MsgResumeHostZone, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _133.MsgResumeHostZone;
            fromPartial(object: {
                creator?: string;
            }): _133.MsgResumeHostZone;
        };
        MsgResumeHostZoneResponse: {
            encode(_: _133.MsgResumeHostZoneResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _133.MsgResumeHostZoneResponse;
            fromPartial(_: {}): _133.MsgResumeHostZoneResponse;
        };
        MsgRefreshRedemptionRate: {
            encode(message: _133.MsgRefreshRedemptionRate, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _133.MsgRefreshRedemptionRate;
            fromPartial(object: {
                creator?: string;
            }): _133.MsgRefreshRedemptionRate;
        };
        MsgRefreshRedemptionRateResponse: {
            encode(_: _133.MsgRefreshRedemptionRateResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _133.MsgRefreshRedemptionRateResponse;
            fromPartial(_: {}): _133.MsgRefreshRedemptionRateResponse;
        };
        MsgOverwriteDelegationRecord: {
            encode(message: _133.MsgOverwriteDelegationRecord, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _133.MsgOverwriteDelegationRecord;
            fromPartial(object: {
                creator?: string;
                delegationRecord?: {
                    id?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    nativeAmount?: string;
                    status?: _132.DelegationRecordStatus;
                    txHash?: string;
                };
            }): _133.MsgOverwriteDelegationRecord;
        };
        MsgOverwriteDelegationRecordResponse: {
            encode(_: _133.MsgOverwriteDelegationRecordResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _133.MsgOverwriteDelegationRecordResponse;
            fromPartial(_: {}): _133.MsgOverwriteDelegationRecordResponse;
        };
        MsgOverwriteUnbondingRecord: {
            encode(message: _133.MsgOverwriteUnbondingRecord, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _133.MsgOverwriteUnbondingRecord;
            fromPartial(object: {
                creator?: string;
                unbondingRecord?: {
                    id?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    status?: _132.UnbondingRecordStatus;
                    stTokenAmount?: string;
                    nativeAmount?: string;
                    unbondingCompletionTimeSeconds?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    undelegationTxHash?: string;
                    unbondedTokenSweepTxHash?: string;
                };
            }): _133.MsgOverwriteUnbondingRecord;
        };
        MsgOverwriteUnbondingRecordResponse: {
            encode(_: _133.MsgOverwriteUnbondingRecordResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _133.MsgOverwriteUnbondingRecordResponse;
            fromPartial(_: {}): _133.MsgOverwriteUnbondingRecordResponse;
        };
        MsgOverwriteRedemptionRecord: {
            encode(message: _133.MsgOverwriteRedemptionRecord, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _133.MsgOverwriteRedemptionRecord;
            fromPartial(object: {
                creator?: string;
                redemptionRecord?: {
                    unbondingRecordId?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    redeemer?: string;
                    stTokenAmount?: string;
                    nativeAmount?: string;
                };
            }): _133.MsgOverwriteRedemptionRecord;
        };
        MsgOverwriteRedemptionRecordResponse: {
            encode(_: _133.MsgOverwriteRedemptionRecordResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _133.MsgOverwriteRedemptionRecordResponse;
            fromPartial(_: {}): _133.MsgOverwriteRedemptionRecordResponse;
        };
        MsgSetOperatorAddress: {
            encode(message: _133.MsgSetOperatorAddress, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _133.MsgSetOperatorAddress;
            fromPartial(object: {
                signer?: string;
                operator?: string;
            }): _133.MsgSetOperatorAddress;
        };
        MsgSetOperatorAddressResponse: {
            encode(_: _133.MsgSetOperatorAddressResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _133.MsgSetOperatorAddressResponse;
            fromPartial(_: {}): _133.MsgSetOperatorAddressResponse;
        };
        delegationRecordStatusFromJSON(object: any): _132.DelegationRecordStatus;
        delegationRecordStatusToJSON(object: _132.DelegationRecordStatus): string;
        unbondingRecordStatusFromJSON(object: any): _132.UnbondingRecordStatus;
        unbondingRecordStatusToJSON(object: _132.UnbondingRecordStatus): string;
        DelegationRecordStatus: typeof _132.DelegationRecordStatus;
        DelegationRecordStatusSDKType: typeof _132.DelegationRecordStatusSDKType;
        UnbondingRecordStatus: typeof _132.UnbondingRecordStatus;
        UnbondingRecordStatusSDKType: typeof _132.UnbondingRecordStatusSDKType;
        HostZone: {
            encode(message: _132.HostZone, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _132.HostZone;
            fromPartial(object: {
                chainId?: string;
                nativeTokenDenom?: string;
                nativeTokenIbcDenom?: string;
                transferChannelId?: string;
                delegationAddress?: string;
                rewardAddress?: string;
                depositAddress?: string;
                redemptionAddress?: string;
                claimAddress?: string;
                operatorAddressOnStride?: string;
                safeAddressOnStride?: string;
                lastRedemptionRate?: string;
                redemptionRate?: string;
                minRedemptionRate?: string;
                maxRedemptionRate?: string;
                minInnerRedemptionRate?: string;
                maxInnerRedemptionRate?: string;
                delegatedBalance?: string;
                unbondingPeriodSeconds?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                halted?: boolean;
            }): _132.HostZone;
        };
        DelegationRecord: {
            encode(message: _132.DelegationRecord, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _132.DelegationRecord;
            fromPartial(object: {
                id?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                nativeAmount?: string;
                status?: _132.DelegationRecordStatus;
                txHash?: string;
            }): _132.DelegationRecord;
        };
        UnbondingRecord: {
            encode(message: _132.UnbondingRecord, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _132.UnbondingRecord;
            fromPartial(object: {
                id?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                status?: _132.UnbondingRecordStatus;
                stTokenAmount?: string;
                nativeAmount?: string;
                unbondingCompletionTimeSeconds?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                undelegationTxHash?: string;
                unbondedTokenSweepTxHash?: string;
            }): _132.UnbondingRecord;
        };
        RedemptionRecord: {
            encode(message: _132.RedemptionRecord, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _132.RedemptionRecord;
            fromPartial(object: {
                unbondingRecordId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                redeemer?: string;
                stTokenAmount?: string;
                nativeAmount?: string;
            }): _132.RedemptionRecord;
        };
        SlashRecord: {
            encode(message: _132.SlashRecord, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _132.SlashRecord;
            fromPartial(object: {
                id?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                time?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                nativeAmount?: string;
                validatorAddress?: string;
            }): _132.SlashRecord;
        };
        QueryHostZoneRequest: {
            encode(_: _131.QueryHostZoneRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _131.QueryHostZoneRequest;
            fromPartial(_: {}): _131.QueryHostZoneRequest;
        };
        QueryHostZoneResponse: {
            encode(message: _131.QueryHostZoneResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _131.QueryHostZoneResponse;
            fromPartial(object: {
                hostZone?: {
                    chainId?: string;
                    nativeTokenDenom?: string;
                    nativeTokenIbcDenom?: string;
                    transferChannelId?: string;
                    delegationAddress?: string;
                    rewardAddress?: string;
                    depositAddress?: string;
                    redemptionAddress?: string;
                    claimAddress?: string;
                    operatorAddressOnStride?: string;
                    safeAddressOnStride?: string;
                    lastRedemptionRate?: string;
                    redemptionRate?: string;
                    minRedemptionRate?: string;
                    maxRedemptionRate?: string;
                    minInnerRedemptionRate?: string;
                    maxInnerRedemptionRate?: string;
                    delegatedBalance?: string;
                    unbondingPeriodSeconds?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    halted?: boolean;
                };
            }): _131.QueryHostZoneResponse;
        };
        QueryDelegationRecordsRequest: {
            encode(message: _131.QueryDelegationRecordsRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _131.QueryDelegationRecordsRequest;
            fromPartial(object: {
                includeArchived?: boolean;
            }): _131.QueryDelegationRecordsRequest;
        };
        QueryDelegationRecordsResponse: {
            encode(message: _131.QueryDelegationRecordsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _131.QueryDelegationRecordsResponse;
            fromPartial(object: {
                delegationRecords?: {
                    id?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    nativeAmount?: string;
                    status?: _132.DelegationRecordStatus;
                    txHash?: string;
                }[];
            }): _131.QueryDelegationRecordsResponse;
        };
        QueryUnbondingRecordsRequest: {
            encode(message: _131.QueryUnbondingRecordsRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _131.QueryUnbondingRecordsRequest;
            fromPartial(object: {
                includeArchived?: boolean;
            }): _131.QueryUnbondingRecordsRequest;
        };
        QueryUnbondingRecordsResponse: {
            encode(message: _131.QueryUnbondingRecordsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _131.QueryUnbondingRecordsResponse;
            fromPartial(object: {
                unbondingRecords?: {
                    id?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    status?: _132.UnbondingRecordStatus;
                    stTokenAmount?: string;
                    nativeAmount?: string;
                    unbondingCompletionTimeSeconds?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    undelegationTxHash?: string;
                    unbondedTokenSweepTxHash?: string;
                }[];
            }): _131.QueryUnbondingRecordsResponse;
        };
        QueryRedemptionRecordRequest: {
            encode(message: _131.QueryRedemptionRecordRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _131.QueryRedemptionRecordRequest;
            fromPartial(object: {
                unbondingRecordId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                address?: string;
            }): _131.QueryRedemptionRecordRequest;
        };
        QueryRedemptionRecordResponse: {
            encode(message: _131.QueryRedemptionRecordResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _131.QueryRedemptionRecordResponse;
            fromPartial(object: {
                redemptionRecordResponse?: {
                    redemptionRecord?: {
                        unbondingRecordId?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        redeemer?: string;
                        stTokenAmount?: string;
                        nativeAmount?: string;
                    };
                    unbondingCompletionTimeSeconds?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                };
            }): _131.QueryRedemptionRecordResponse;
        };
        QueryRedemptionRecordsRequest: {
            encode(message: _131.QueryRedemptionRecordsRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _131.QueryRedemptionRecordsRequest;
            fromPartial(object: {
                address?: string;
                unbondingRecordId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                pagination?: {
                    key?: Uint8Array;
                    offset?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    limit?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    countTotal?: boolean;
                    reverse?: boolean;
                };
            }): _131.QueryRedemptionRecordsRequest;
        };
        QueryRedemptionRecordsResponse: {
            encode(message: _131.QueryRedemptionRecordsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _131.QueryRedemptionRecordsResponse;
            fromPartial(object: {
                redemptionRecordResponses?: {
                    redemptionRecord?: {
                        unbondingRecordId?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        redeemer?: string;
                        stTokenAmount?: string;
                        nativeAmount?: string;
                    };
                    unbondingCompletionTimeSeconds?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                }[];
                pagination?: {
                    nextKey?: Uint8Array;
                    total?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                };
            }): _131.QueryRedemptionRecordsResponse;
        };
        QuerySlashRecordsRequest: {
            encode(_: _131.QuerySlashRecordsRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _131.QuerySlashRecordsRequest;
            fromPartial(_: {}): _131.QuerySlashRecordsRequest;
        };
        QuerySlashRecordsResponse: {
            encode(message: _131.QuerySlashRecordsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _131.QuerySlashRecordsResponse;
            fromPartial(object: {
                slashRecords?: {
                    id?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    time?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    nativeAmount?: string;
                    validatorAddress?: string;
                }[];
            }): _131.QuerySlashRecordsResponse;
        };
        RedemptionRecordResponse: {
            encode(message: _131.RedemptionRecordResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _131.RedemptionRecordResponse;
            fromPartial(object: {
                redemptionRecord?: {
                    unbondingRecordId?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    redeemer?: string;
                    stTokenAmount?: string;
                    nativeAmount?: string;
                };
                unbondingCompletionTimeSeconds?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
            }): _131.RedemptionRecordResponse;
        };
        Params: {
            encode(_: _130.Params, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _130.Params;
            fromPartial(_: {}): _130.Params;
        };
        TransferInProgressRecordIds: {
            encode(message: _130.TransferInProgressRecordIds, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _130.TransferInProgressRecordIds;
            fromPartial(object: {
                channelId?: string;
                sequence?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                recordId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
            }): _130.TransferInProgressRecordIds;
        };
        GenesisState: {
            encode(message: _130.GenesisState, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _130.GenesisState;
            fromPartial(object: {
                params?: {};
                hostZone?: {
                    chainId?: string;
                    nativeTokenDenom?: string;
                    nativeTokenIbcDenom?: string;
                    transferChannelId?: string;
                    delegationAddress?: string;
                    rewardAddress?: string;
                    depositAddress?: string;
                    redemptionAddress?: string;
                    claimAddress?: string;
                    operatorAddressOnStride?: string;
                    safeAddressOnStride?: string;
                    lastRedemptionRate?: string;
                    redemptionRate?: string;
                    minRedemptionRate?: string;
                    maxRedemptionRate?: string;
                    minInnerRedemptionRate?: string;
                    maxInnerRedemptionRate?: string;
                    delegatedBalance?: string;
                    unbondingPeriodSeconds?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    halted?: boolean;
                };
                delegationRecords?: {
                    id?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    nativeAmount?: string;
                    status?: _132.DelegationRecordStatus;
                    txHash?: string;
                }[];
                unbondingRecords?: {
                    id?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    status?: _132.UnbondingRecordStatus;
                    stTokenAmount?: string;
                    nativeAmount?: string;
                    unbondingCompletionTimeSeconds?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    undelegationTxHash?: string;
                    unbondedTokenSweepTxHash?: string;
                }[];
                redemptionRecords?: {
                    unbondingRecordId?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    redeemer?: string;
                    stTokenAmount?: string;
                    nativeAmount?: string;
                }[];
                slashRecords?: {
                    id?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    time?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    nativeAmount?: string;
                    validatorAddress?: string;
                }[];
                transferInProgressRecordIds?: {
                    channelId?: string;
                    sequence?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    recordId?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                }[];
            }): _130.GenesisState;
        };
    };
    const stakeibc: {
        MsgClientImpl: typeof _267.MsgClientImpl;
        QueryClientImpl: typeof _260.QueryClientImpl;
        createRpcQueryExtension: (base: import("@cosmjs/stargate").QueryClient) => {
            params(request?: _143.QueryParamsRequest): Promise<_143.QueryParamsResponse>;
            validators(request: _143.QueryGetValidatorsRequest): Promise<_143.QueryGetValidatorsResponse>;
            hostZone(request: _143.QueryGetHostZoneRequest): Promise<_143.QueryGetHostZoneResponse>;
            hostZoneAll(request?: _143.QueryAllHostZoneRequest): Promise<_143.QueryAllHostZoneResponse>;
            moduleAddress(request: _143.QueryModuleAddressRequest): Promise<_143.QueryModuleAddressResponse>;
            interchainAccountFromAddress(request: _143.QueryInterchainAccountFromAddressRequest): Promise<_143.QueryInterchainAccountFromAddressResponse>;
            epochTracker(request: _143.QueryGetEpochTrackerRequest): Promise<_143.QueryGetEpochTrackerResponse>;
            epochTrackerAll(request?: _143.QueryAllEpochTrackerRequest): Promise<_143.QueryAllEpochTrackerResponse>;
            nextPacketSequence(request: _143.QueryGetNextPacketSequenceRequest): Promise<_143.QueryGetNextPacketSequenceResponse>;
            addressUnbondings(request: _143.QueryAddressUnbondings): Promise<_143.QueryAddressUnbondingsResponse>;
            allTradeRoutes(request?: _143.QueryAllTradeRoutes): Promise<_143.QueryAllTradeRoutesResponse>;
        };
        LCDQueryClient: typeof _249.LCDQueryClient;
        registry: readonly [string, import("@cosmjs/proto-signing").GeneratedType][];
        load: (protoRegistry: import("@cosmjs/proto-signing").Registry) => void;
        MessageComposer: {
            encoded: {
                liquidStake(value: _145.MsgLiquidStake): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                lSMLiquidStake(value: _145.MsgLSMLiquidStake): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                redeemStake(value: _145.MsgRedeemStake): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                registerHostZone(value: _145.MsgRegisterHostZone): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                claimUndelegatedTokens(value: _145.MsgClaimUndelegatedTokens): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                rebalanceValidators(value: _145.MsgRebalanceValidators): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                addValidators(value: _145.MsgAddValidators): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                changeValidatorWeight(value: _145.MsgChangeValidatorWeights): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                deleteValidator(value: _145.MsgDeleteValidator): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                restoreInterchainAccount(value: _145.MsgRestoreInterchainAccount): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                updateValidatorSharesExchRate(value: _145.MsgUpdateValidatorSharesExchRate): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                calibrateDelegation(value: _145.MsgCalibrateDelegation): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                clearBalance(value: _145.MsgClearBalance): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                updateInnerRedemptionRateBounds(value: _145.MsgUpdateInnerRedemptionRateBounds): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                resumeHostZone(value: _145.MsgResumeHostZone): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                createTradeRoute(value: _145.MsgCreateTradeRoute): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                deleteTradeRoute(value: _145.MsgDeleteTradeRoute): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                updateTradeRoute(value: _145.MsgUpdateTradeRoute): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                setCommunityPoolRebate(value: _145.MsgSetCommunityPoolRebate): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                toggleTradeController(value: _145.MsgToggleTradeController): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                updateHostZoneParams(value: _145.MsgUpdateHostZoneParams): {
                    typeUrl: string;
                    value: Uint8Array;
                };
            };
            withTypeUrl: {
                liquidStake(value: _145.MsgLiquidStake): {
                    typeUrl: string;
                    value: _145.MsgLiquidStake;
                };
                lSMLiquidStake(value: _145.MsgLSMLiquidStake): {
                    typeUrl: string;
                    value: _145.MsgLSMLiquidStake;
                };
                redeemStake(value: _145.MsgRedeemStake): {
                    typeUrl: string;
                    value: _145.MsgRedeemStake;
                };
                registerHostZone(value: _145.MsgRegisterHostZone): {
                    typeUrl: string;
                    value: _145.MsgRegisterHostZone;
                };
                claimUndelegatedTokens(value: _145.MsgClaimUndelegatedTokens): {
                    typeUrl: string;
                    value: _145.MsgClaimUndelegatedTokens;
                };
                rebalanceValidators(value: _145.MsgRebalanceValidators): {
                    typeUrl: string;
                    value: _145.MsgRebalanceValidators;
                };
                addValidators(value: _145.MsgAddValidators): {
                    typeUrl: string;
                    value: _145.MsgAddValidators;
                };
                changeValidatorWeight(value: _145.MsgChangeValidatorWeights): {
                    typeUrl: string;
                    value: _145.MsgChangeValidatorWeights;
                };
                deleteValidator(value: _145.MsgDeleteValidator): {
                    typeUrl: string;
                    value: _145.MsgDeleteValidator;
                };
                restoreInterchainAccount(value: _145.MsgRestoreInterchainAccount): {
                    typeUrl: string;
                    value: _145.MsgRestoreInterchainAccount;
                };
                updateValidatorSharesExchRate(value: _145.MsgUpdateValidatorSharesExchRate): {
                    typeUrl: string;
                    value: _145.MsgUpdateValidatorSharesExchRate;
                };
                calibrateDelegation(value: _145.MsgCalibrateDelegation): {
                    typeUrl: string;
                    value: _145.MsgCalibrateDelegation;
                };
                clearBalance(value: _145.MsgClearBalance): {
                    typeUrl: string;
                    value: _145.MsgClearBalance;
                };
                updateInnerRedemptionRateBounds(value: _145.MsgUpdateInnerRedemptionRateBounds): {
                    typeUrl: string;
                    value: _145.MsgUpdateInnerRedemptionRateBounds;
                };
                resumeHostZone(value: _145.MsgResumeHostZone): {
                    typeUrl: string;
                    value: _145.MsgResumeHostZone;
                };
                createTradeRoute(value: _145.MsgCreateTradeRoute): {
                    typeUrl: string;
                    value: _145.MsgCreateTradeRoute;
                };
                deleteTradeRoute(value: _145.MsgDeleteTradeRoute): {
                    typeUrl: string;
                    value: _145.MsgDeleteTradeRoute;
                };
                updateTradeRoute(value: _145.MsgUpdateTradeRoute): {
                    typeUrl: string;
                    value: _145.MsgUpdateTradeRoute;
                };
                setCommunityPoolRebate(value: _145.MsgSetCommunityPoolRebate): {
                    typeUrl: string;
                    value: _145.MsgSetCommunityPoolRebate;
                };
                toggleTradeController(value: _145.MsgToggleTradeController): {
                    typeUrl: string;
                    value: _145.MsgToggleTradeController;
                };
                updateHostZoneParams(value: _145.MsgUpdateHostZoneParams): {
                    typeUrl: string;
                    value: _145.MsgUpdateHostZoneParams;
                };
            };
            fromPartial: {
                liquidStake(value: _145.MsgLiquidStake): {
                    typeUrl: string;
                    value: _145.MsgLiquidStake;
                };
                lSMLiquidStake(value: _145.MsgLSMLiquidStake): {
                    typeUrl: string;
                    value: _145.MsgLSMLiquidStake;
                };
                redeemStake(value: _145.MsgRedeemStake): {
                    typeUrl: string;
                    value: _145.MsgRedeemStake;
                };
                registerHostZone(value: _145.MsgRegisterHostZone): {
                    typeUrl: string;
                    value: _145.MsgRegisterHostZone;
                };
                claimUndelegatedTokens(value: _145.MsgClaimUndelegatedTokens): {
                    typeUrl: string;
                    value: _145.MsgClaimUndelegatedTokens;
                };
                rebalanceValidators(value: _145.MsgRebalanceValidators): {
                    typeUrl: string;
                    value: _145.MsgRebalanceValidators;
                };
                addValidators(value: _145.MsgAddValidators): {
                    typeUrl: string;
                    value: _145.MsgAddValidators;
                };
                changeValidatorWeight(value: _145.MsgChangeValidatorWeights): {
                    typeUrl: string;
                    value: _145.MsgChangeValidatorWeights;
                };
                deleteValidator(value: _145.MsgDeleteValidator): {
                    typeUrl: string;
                    value: _145.MsgDeleteValidator;
                };
                restoreInterchainAccount(value: _145.MsgRestoreInterchainAccount): {
                    typeUrl: string;
                    value: _145.MsgRestoreInterchainAccount;
                };
                updateValidatorSharesExchRate(value: _145.MsgUpdateValidatorSharesExchRate): {
                    typeUrl: string;
                    value: _145.MsgUpdateValidatorSharesExchRate;
                };
                calibrateDelegation(value: _145.MsgCalibrateDelegation): {
                    typeUrl: string;
                    value: _145.MsgCalibrateDelegation;
                };
                clearBalance(value: _145.MsgClearBalance): {
                    typeUrl: string;
                    value: _145.MsgClearBalance;
                };
                updateInnerRedemptionRateBounds(value: _145.MsgUpdateInnerRedemptionRateBounds): {
                    typeUrl: string;
                    value: _145.MsgUpdateInnerRedemptionRateBounds;
                };
                resumeHostZone(value: _145.MsgResumeHostZone): {
                    typeUrl: string;
                    value: _145.MsgResumeHostZone;
                };
                createTradeRoute(value: _145.MsgCreateTradeRoute): {
                    typeUrl: string;
                    value: _145.MsgCreateTradeRoute;
                };
                deleteTradeRoute(value: _145.MsgDeleteTradeRoute): {
                    typeUrl: string;
                    value: _145.MsgDeleteTradeRoute;
                };
                updateTradeRoute(value: _145.MsgUpdateTradeRoute): {
                    typeUrl: string;
                    value: _145.MsgUpdateTradeRoute;
                };
                setCommunityPoolRebate(value: _145.MsgSetCommunityPoolRebate): {
                    typeUrl: string;
                    value: _145.MsgSetCommunityPoolRebate;
                };
                toggleTradeController(value: _145.MsgToggleTradeController): {
                    typeUrl: string;
                    value: _145.MsgToggleTradeController;
                };
                updateHostZoneParams(value: _145.MsgUpdateHostZoneParams): {
                    typeUrl: string;
                    value: _145.MsgUpdateHostZoneParams;
                };
            };
        };
        AminoConverter: {
            "/stride.stakeibc.MsgLiquidStake": {
                aminoType: string;
                toAmino: ({ creator, amount, hostDenom }: _145.MsgLiquidStake) => {
                    creator: string;
                    amount: string;
                    host_denom: string;
                };
                fromAmino: ({ creator, amount, host_denom }: {
                    creator: string;
                    amount: string;
                    host_denom: string;
                }) => _145.MsgLiquidStake;
            };
            "/stride.stakeibc.MsgLSMLiquidStake": {
                aminoType: string;
                toAmino: ({ creator, amount, lsmTokenIbcDenom }: _145.MsgLSMLiquidStake) => {
                    creator: string;
                    amount: string;
                    lsm_token_ibc_denom: string;
                };
                fromAmino: ({ creator, amount, lsm_token_ibc_denom }: {
                    creator: string;
                    amount: string;
                    lsm_token_ibc_denom: string;
                }) => _145.MsgLSMLiquidStake;
            };
            "/stride.stakeibc.MsgRedeemStake": {
                aminoType: string;
                toAmino: ({ creator, amount, hostZone, receiver }: _145.MsgRedeemStake) => {
                    creator: string;
                    amount: string;
                    host_zone: string;
                    receiver: string;
                };
                fromAmino: ({ creator, amount, host_zone, receiver }: {
                    creator: string;
                    amount: string;
                    host_zone: string;
                    receiver: string;
                }) => _145.MsgRedeemStake;
            };
            "/stride.stakeibc.MsgRegisterHostZone": {
                aminoType: string;
                toAmino: ({ connectionId, bech32prefix, hostDenom, ibcDenom, creator, transferChannelId, unbondingPeriod, minRedemptionRate, maxRedemptionRate, lsmLiquidStakeEnabled, communityPoolTreasuryAddress, maxMessagesPerIcaTx }: _145.MsgRegisterHostZone) => {
                    connection_id: string;
                    bech32prefix: string;
                    host_denom: string;
                    ibc_denom: string;
                    creator: string;
                    transfer_channel_id: string;
                    unbonding_period: string;
                    min_redemption_rate: string;
                    max_redemption_rate: string;
                    lsm_liquid_stake_enabled: boolean;
                    community_pool_treasury_address: string;
                    max_messages_per_ica_tx: string;
                };
                fromAmino: ({ connection_id, bech32prefix, host_denom, ibc_denom, creator, transfer_channel_id, unbonding_period, min_redemption_rate, max_redemption_rate, lsm_liquid_stake_enabled, community_pool_treasury_address, max_messages_per_ica_tx }: {
                    connection_id: string;
                    bech32prefix: string;
                    host_denom: string;
                    ibc_denom: string;
                    creator: string;
                    transfer_channel_id: string;
                    unbonding_period: string;
                    min_redemption_rate: string;
                    max_redemption_rate: string;
                    lsm_liquid_stake_enabled: boolean;
                    community_pool_treasury_address: string;
                    max_messages_per_ica_tx: string;
                }) => _145.MsgRegisterHostZone;
            };
            "/stride.stakeibc.MsgClaimUndelegatedTokens": {
                aminoType: string;
                toAmino: ({ creator, hostZoneId, epoch, receiver }: _145.MsgClaimUndelegatedTokens) => {
                    creator: string;
                    host_zone_id: string;
                    epoch: string;
                    receiver: string;
                };
                fromAmino: ({ creator, host_zone_id, epoch, receiver }: {
                    creator: string;
                    host_zone_id: string;
                    epoch: string;
                    receiver: string;
                }) => _145.MsgClaimUndelegatedTokens;
            };
            "/stride.stakeibc.MsgRebalanceValidators": {
                aminoType: string;
                toAmino: ({ creator, hostZone, numRebalance }: _145.MsgRebalanceValidators) => {
                    creator: string;
                    host_zone: string;
                    num_rebalance: string;
                };
                fromAmino: ({ creator, host_zone, num_rebalance }: {
                    creator: string;
                    host_zone: string;
                    num_rebalance: string;
                }) => _145.MsgRebalanceValidators;
            };
            "/stride.stakeibc.MsgAddValidators": {
                aminoType: string;
                toAmino: ({ creator, hostZone, validators }: _145.MsgAddValidators) => {
                    creator: string;
                    host_zone: string;
                    validators: {
                        name: string;
                        address: string;
                        weight: string;
                        delegation: string;
                        slash_query_progress_tracker: string;
                        slash_query_checkpoint: string;
                        shares_to_tokens_rate: string;
                        delegation_changes_in_progress: string;
                        slash_query_in_progress: boolean;
                    }[];
                };
                fromAmino: ({ creator, host_zone, validators }: {
                    creator: string;
                    host_zone: string;
                    validators: {
                        name: string;
                        address: string;
                        weight: string;
                        delegation: string;
                        slash_query_progress_tracker: string;
                        slash_query_checkpoint: string;
                        shares_to_tokens_rate: string;
                        delegation_changes_in_progress: string;
                        slash_query_in_progress: boolean;
                    }[];
                }) => _145.MsgAddValidators;
            };
            "/stride.stakeibc.MsgChangeValidatorWeights": {
                aminoType: string;
                toAmino: ({ creator, hostZone, validatorWeights }: _145.MsgChangeValidatorWeights) => {
                    creator: string;
                    host_zone: string;
                    validator_weights: {
                        address: string;
                        weight: string;
                    }[];
                };
                fromAmino: ({ creator, host_zone, validator_weights }: {
                    creator: string;
                    host_zone: string;
                    validator_weights: {
                        address: string;
                        weight: string;
                    }[];
                }) => _145.MsgChangeValidatorWeights;
            };
            "/stride.stakeibc.MsgDeleteValidator": {
                aminoType: string;
                toAmino: ({ creator, hostZone, valAddr }: _145.MsgDeleteValidator) => {
                    creator: string;
                    host_zone: string;
                    val_addr: string;
                };
                fromAmino: ({ creator, host_zone, val_addr }: {
                    creator: string;
                    host_zone: string;
                    val_addr: string;
                }) => _145.MsgDeleteValidator;
            };
            "/stride.stakeibc.MsgRestoreInterchainAccount": {
                aminoType: string;
                toAmino: ({ creator, chainId, connectionId, accountOwner }: _145.MsgRestoreInterchainAccount) => {
                    creator: string;
                    chain_id: string;
                    connection_id: string;
                    account_owner: string;
                };
                fromAmino: ({ creator, chain_id, connection_id, account_owner }: {
                    creator: string;
                    chain_id: string;
                    connection_id: string;
                    account_owner: string;
                }) => _145.MsgRestoreInterchainAccount;
            };
            "/stride.stakeibc.MsgUpdateValidatorSharesExchRate": {
                aminoType: string;
                toAmino: ({ creator, chainId, valoper }: _145.MsgUpdateValidatorSharesExchRate) => {
                    creator: string;
                    chain_id: string;
                    valoper: string;
                };
                fromAmino: ({ creator, chain_id, valoper }: {
                    creator: string;
                    chain_id: string;
                    valoper: string;
                }) => _145.MsgUpdateValidatorSharesExchRate;
            };
            "/stride.stakeibc.MsgCalibrateDelegation": {
                aminoType: string;
                toAmino: ({ creator, chainId, valoper }: _145.MsgCalibrateDelegation) => {
                    creator: string;
                    chain_id: string;
                    valoper: string;
                };
                fromAmino: ({ creator, chain_id, valoper }: {
                    creator: string;
                    chain_id: string;
                    valoper: string;
                }) => _145.MsgCalibrateDelegation;
            };
            "/stride.stakeibc.MsgClearBalance": {
                aminoType: string;
                toAmino: ({ creator, chainId, amount, channel }: _145.MsgClearBalance) => {
                    creator: string;
                    chain_id: string;
                    amount: string;
                    channel: string;
                };
                fromAmino: ({ creator, chain_id, amount, channel }: {
                    creator: string;
                    chain_id: string;
                    amount: string;
                    channel: string;
                }) => _145.MsgClearBalance;
            };
            "/stride.stakeibc.MsgUpdateInnerRedemptionRateBounds": {
                aminoType: string;
                toAmino: ({ creator, chainId, minInnerRedemptionRate, maxInnerRedemptionRate }: _145.MsgUpdateInnerRedemptionRateBounds) => {
                    creator: string;
                    chain_id: string;
                    min_inner_redemption_rate: string;
                    max_inner_redemption_rate: string;
                };
                fromAmino: ({ creator, chain_id, min_inner_redemption_rate, max_inner_redemption_rate }: {
                    creator: string;
                    chain_id: string;
                    min_inner_redemption_rate: string;
                    max_inner_redemption_rate: string;
                }) => _145.MsgUpdateInnerRedemptionRateBounds;
            };
            "/stride.stakeibc.MsgResumeHostZone": {
                aminoType: string;
                toAmino: ({ creator, chainId }: _145.MsgResumeHostZone) => {
                    creator: string;
                    chain_id: string;
                };
                fromAmino: ({ creator, chain_id }: {
                    creator: string;
                    chain_id: string;
                }) => _145.MsgResumeHostZone;
            };
            "/stride.stakeibc.MsgCreateTradeRoute": {
                aminoType: string;
                toAmino: ({ authority, hostChainId, strideToRewardConnectionId, strideToTradeConnectionId, hostToRewardTransferChannelId, rewardToTradeTransferChannelId, tradeToHostTransferChannelId, rewardDenomOnHost, rewardDenomOnReward, rewardDenomOnTrade, hostDenomOnTrade, hostDenomOnHost, poolId, maxAllowedSwapLossRate, minSwapAmount, maxSwapAmount, minTransferAmount }: _145.MsgCreateTradeRoute) => {
                    authority: string;
                    host_chain_id: string;
                    stride_to_reward_connection_id: string;
                    stride_to_trade_connection_id: string;
                    host_to_reward_transfer_channel_id: string;
                    reward_to_trade_transfer_channel_id: string;
                    trade_to_host_transfer_channel_id: string;
                    reward_denom_on_host: string;
                    reward_denom_on_reward: string;
                    reward_denom_on_trade: string;
                    host_denom_on_trade: string;
                    host_denom_on_host: string;
                    pool_id: string;
                    max_allowed_swap_loss_rate: string;
                    min_swap_amount: string;
                    max_swap_amount: string;
                    min_transfer_amount: string;
                };
                fromAmino: ({ authority, host_chain_id, stride_to_reward_connection_id, stride_to_trade_connection_id, host_to_reward_transfer_channel_id, reward_to_trade_transfer_channel_id, trade_to_host_transfer_channel_id, reward_denom_on_host, reward_denom_on_reward, reward_denom_on_trade, host_denom_on_trade, host_denom_on_host, pool_id, max_allowed_swap_loss_rate, min_swap_amount, max_swap_amount, min_transfer_amount }: {
                    authority: string;
                    host_chain_id: string;
                    stride_to_reward_connection_id: string;
                    stride_to_trade_connection_id: string;
                    host_to_reward_transfer_channel_id: string;
                    reward_to_trade_transfer_channel_id: string;
                    trade_to_host_transfer_channel_id: string;
                    reward_denom_on_host: string;
                    reward_denom_on_reward: string;
                    reward_denom_on_trade: string;
                    host_denom_on_trade: string;
                    host_denom_on_host: string;
                    pool_id: string;
                    max_allowed_swap_loss_rate: string;
                    min_swap_amount: string;
                    max_swap_amount: string;
                    min_transfer_amount: string;
                }) => _145.MsgCreateTradeRoute;
            };
            "/stride.stakeibc.MsgDeleteTradeRoute": {
                aminoType: string;
                toAmino: ({ authority, rewardDenom, hostDenom }: _145.MsgDeleteTradeRoute) => {
                    authority: string;
                    reward_denom: string;
                    host_denom: string;
                };
                fromAmino: ({ authority, reward_denom, host_denom }: {
                    authority: string;
                    reward_denom: string;
                    host_denom: string;
                }) => _145.MsgDeleteTradeRoute;
            };
            "/stride.stakeibc.MsgUpdateTradeRoute": {
                aminoType: string;
                toAmino: ({ authority, rewardDenom, hostDenom, poolId, maxAllowedSwapLossRate, minSwapAmount, maxSwapAmount, minTransferAmount }: _145.MsgUpdateTradeRoute) => {
                    authority: string;
                    reward_denom: string;
                    host_denom: string;
                    pool_id: string;
                    max_allowed_swap_loss_rate: string;
                    min_swap_amount: string;
                    max_swap_amount: string;
                    min_transfer_amount: string;
                };
                fromAmino: ({ authority, reward_denom, host_denom, pool_id, max_allowed_swap_loss_rate, min_swap_amount, max_swap_amount, min_transfer_amount }: {
                    authority: string;
                    reward_denom: string;
                    host_denom: string;
                    pool_id: string;
                    max_allowed_swap_loss_rate: string;
                    min_swap_amount: string;
                    max_swap_amount: string;
                    min_transfer_amount: string;
                }) => _145.MsgUpdateTradeRoute;
            };
            "/stride.stakeibc.MsgSetCommunityPoolRebate": {
                aminoType: string;
                toAmino: ({ creator, chainId, rebateRate, liquidStakedStTokenAmount }: _145.MsgSetCommunityPoolRebate) => {
                    creator: string;
                    chain_id: string;
                    rebate_rate: string;
                    liquid_staked_st_token_amount: string;
                };
                fromAmino: ({ creator, chain_id, rebate_rate, liquid_staked_st_token_amount }: {
                    creator: string;
                    chain_id: string;
                    rebate_rate: string;
                    liquid_staked_st_token_amount: string;
                }) => _145.MsgSetCommunityPoolRebate;
            };
            "/stride.stakeibc.MsgToggleTradeController": {
                aminoType: string;
                toAmino: ({ creator, chainId, permissionChange, address }: _145.MsgToggleTradeController) => {
                    creator: string;
                    chain_id: string;
                    permission_change: number;
                    address: string;
                };
                fromAmino: ({ creator, chain_id, permission_change, address }: {
                    creator: string;
                    chain_id: string;
                    permission_change: number;
                    address: string;
                }) => _145.MsgToggleTradeController;
            };
            "/stride.stakeibc.MsgUpdateHostZoneParams": {
                aminoType: string;
                toAmino: ({ authority, chainId, maxMessagesPerIcaTx }: _145.MsgUpdateHostZoneParams) => {
                    authority: string;
                    chain_id: string;
                    max_messages_per_ica_tx: string;
                };
                fromAmino: ({ authority, chain_id, max_messages_per_ica_tx }: {
                    authority: string;
                    chain_id: string;
                    max_messages_per_ica_tx: string;
                }) => _145.MsgUpdateHostZoneParams;
            };
        };
        Validator: {
            encode(message: _146.Validator, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _146.Validator;
            fromPartial(object: {
                name?: string;
                address?: string;
                weight?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                delegation?: string;
                slashQueryProgressTracker?: string;
                slashQueryCheckpoint?: string;
                sharesToTokensRate?: string;
                delegationChangesInProgress?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                slashQueryInProgress?: boolean;
            }): _146.Validator;
        };
        authzPermissionChangeFromJSON(object: any): _145.AuthzPermissionChange;
        authzPermissionChangeToJSON(object: _145.AuthzPermissionChange): string;
        AuthzPermissionChange: typeof _145.AuthzPermissionChange;
        AuthzPermissionChangeSDKType: typeof _145.AuthzPermissionChangeSDKType;
        MsgUpdateInnerRedemptionRateBounds: {
            encode(message: _145.MsgUpdateInnerRedemptionRateBounds, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.MsgUpdateInnerRedemptionRateBounds;
            fromPartial(object: {
                creator?: string;
                chainId?: string;
                minInnerRedemptionRate?: string;
                maxInnerRedemptionRate?: string;
            }): _145.MsgUpdateInnerRedemptionRateBounds;
        };
        MsgUpdateInnerRedemptionRateBoundsResponse: {
            encode(_: _145.MsgUpdateInnerRedemptionRateBoundsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.MsgUpdateInnerRedemptionRateBoundsResponse;
            fromPartial(_: {}): _145.MsgUpdateInnerRedemptionRateBoundsResponse;
        };
        MsgLiquidStake: {
            encode(message: _145.MsgLiquidStake, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.MsgLiquidStake;
            fromPartial(object: {
                creator?: string;
                amount?: string;
                hostDenom?: string;
            }): _145.MsgLiquidStake;
        };
        MsgLiquidStakeResponse: {
            encode(message: _145.MsgLiquidStakeResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.MsgLiquidStakeResponse;
            fromPartial(object: {
                stToken?: {
                    denom?: string;
                    amount?: string;
                };
            }): _145.MsgLiquidStakeResponse;
        };
        MsgLSMLiquidStake: {
            encode(message: _145.MsgLSMLiquidStake, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.MsgLSMLiquidStake;
            fromPartial(object: {
                creator?: string;
                amount?: string;
                lsmTokenIbcDenom?: string;
            }): _145.MsgLSMLiquidStake;
        };
        MsgLSMLiquidStakeResponse: {
            encode(message: _145.MsgLSMLiquidStakeResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.MsgLSMLiquidStakeResponse;
            fromPartial(object: {
                transactionComplete?: boolean;
            }): _145.MsgLSMLiquidStakeResponse;
        };
        MsgClearBalance: {
            encode(message: _145.MsgClearBalance, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.MsgClearBalance;
            fromPartial(object: {
                creator?: string;
                chainId?: string;
                amount?: string;
                channel?: string;
            }): _145.MsgClearBalance;
        };
        MsgClearBalanceResponse: {
            encode(_: _145.MsgClearBalanceResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.MsgClearBalanceResponse;
            fromPartial(_: {}): _145.MsgClearBalanceResponse;
        };
        MsgRedeemStake: {
            encode(message: _145.MsgRedeemStake, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.MsgRedeemStake;
            fromPartial(object: {
                creator?: string;
                amount?: string;
                hostZone?: string;
                receiver?: string;
            }): _145.MsgRedeemStake;
        };
        MsgRedeemStakeResponse: {
            encode(_: _145.MsgRedeemStakeResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.MsgRedeemStakeResponse;
            fromPartial(_: {}): _145.MsgRedeemStakeResponse;
        };
        MsgRegisterHostZone: {
            encode(message: _145.MsgRegisterHostZone, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.MsgRegisterHostZone;
            fromPartial(object: {
                connectionId?: string;
                bech32prefix?: string;
                hostDenom?: string;
                ibcDenom?: string;
                creator?: string;
                transferChannelId?: string;
                unbondingPeriod?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                minRedemptionRate?: string;
                maxRedemptionRate?: string;
                lsmLiquidStakeEnabled?: boolean;
                communityPoolTreasuryAddress?: string;
                maxMessagesPerIcaTx?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
            }): _145.MsgRegisterHostZone;
        };
        MsgRegisterHostZoneResponse: {
            encode(_: _145.MsgRegisterHostZoneResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.MsgRegisterHostZoneResponse;
            fromPartial(_: {}): _145.MsgRegisterHostZoneResponse;
        };
        MsgClaimUndelegatedTokens: {
            encode(message: _145.MsgClaimUndelegatedTokens, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.MsgClaimUndelegatedTokens;
            fromPartial(object: {
                creator?: string;
                hostZoneId?: string;
                epoch?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                receiver?: string;
            }): _145.MsgClaimUndelegatedTokens;
        };
        MsgClaimUndelegatedTokensResponse: {
            encode(_: _145.MsgClaimUndelegatedTokensResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.MsgClaimUndelegatedTokensResponse;
            fromPartial(_: {}): _145.MsgClaimUndelegatedTokensResponse;
        };
        MsgRebalanceValidators: {
            encode(message: _145.MsgRebalanceValidators, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.MsgRebalanceValidators;
            fromPartial(object: {
                creator?: string;
                hostZone?: string;
                numRebalance?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
            }): _145.MsgRebalanceValidators;
        };
        MsgRebalanceValidatorsResponse: {
            encode(_: _145.MsgRebalanceValidatorsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.MsgRebalanceValidatorsResponse;
            fromPartial(_: {}): _145.MsgRebalanceValidatorsResponse;
        };
        MsgAddValidators: {
            encode(message: _145.MsgAddValidators, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.MsgAddValidators;
            fromPartial(object: {
                creator?: string;
                hostZone?: string;
                validators?: {
                    name?: string;
                    address?: string;
                    weight?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    delegation?: string;
                    slashQueryProgressTracker?: string;
                    slashQueryCheckpoint?: string;
                    sharesToTokensRate?: string;
                    delegationChangesInProgress?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    slashQueryInProgress?: boolean;
                }[];
            }): _145.MsgAddValidators;
        };
        MsgAddValidatorsResponse: {
            encode(_: _145.MsgAddValidatorsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.MsgAddValidatorsResponse;
            fromPartial(_: {}): _145.MsgAddValidatorsResponse;
        };
        ValidatorWeight: {
            encode(message: _145.ValidatorWeight, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.ValidatorWeight;
            fromPartial(object: {
                address?: string;
                weight?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
            }): _145.ValidatorWeight;
        };
        MsgChangeValidatorWeights: {
            encode(message: _145.MsgChangeValidatorWeights, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.MsgChangeValidatorWeights;
            fromPartial(object: {
                creator?: string;
                hostZone?: string;
                validatorWeights?: {
                    address?: string;
                    weight?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                }[];
            }): _145.MsgChangeValidatorWeights;
        };
        MsgChangeValidatorWeightsResponse: {
            encode(_: _145.MsgChangeValidatorWeightsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.MsgChangeValidatorWeightsResponse;
            fromPartial(_: {}): _145.MsgChangeValidatorWeightsResponse;
        };
        MsgDeleteValidator: {
            encode(message: _145.MsgDeleteValidator, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.MsgDeleteValidator;
            fromPartial(object: {
                creator?: string;
                hostZone?: string;
                valAddr?: string;
            }): _145.MsgDeleteValidator;
        };
        MsgDeleteValidatorResponse: {
            encode(_: _145.MsgDeleteValidatorResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.MsgDeleteValidatorResponse;
            fromPartial(_: {}): _145.MsgDeleteValidatorResponse;
        };
        MsgRestoreInterchainAccount: {
            encode(message: _145.MsgRestoreInterchainAccount, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.MsgRestoreInterchainAccount;
            fromPartial(object: {
                creator?: string;
                chainId?: string;
                connectionId?: string;
                accountOwner?: string;
            }): _145.MsgRestoreInterchainAccount;
        };
        MsgRestoreInterchainAccountResponse: {
            encode(_: _145.MsgRestoreInterchainAccountResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.MsgRestoreInterchainAccountResponse;
            fromPartial(_: {}): _145.MsgRestoreInterchainAccountResponse;
        };
        MsgUpdateValidatorSharesExchRate: {
            encode(message: _145.MsgUpdateValidatorSharesExchRate, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.MsgUpdateValidatorSharesExchRate;
            fromPartial(object: {
                creator?: string;
                chainId?: string;
                valoper?: string;
            }): _145.MsgUpdateValidatorSharesExchRate;
        };
        MsgUpdateValidatorSharesExchRateResponse: {
            encode(_: _145.MsgUpdateValidatorSharesExchRateResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.MsgUpdateValidatorSharesExchRateResponse;
            fromPartial(_: {}): _145.MsgUpdateValidatorSharesExchRateResponse;
        };
        MsgCalibrateDelegation: {
            encode(message: _145.MsgCalibrateDelegation, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.MsgCalibrateDelegation;
            fromPartial(object: {
                creator?: string;
                chainId?: string;
                valoper?: string;
            }): _145.MsgCalibrateDelegation;
        };
        MsgCalibrateDelegationResponse: {
            encode(_: _145.MsgCalibrateDelegationResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.MsgCalibrateDelegationResponse;
            fromPartial(_: {}): _145.MsgCalibrateDelegationResponse;
        };
        MsgResumeHostZone: {
            encode(message: _145.MsgResumeHostZone, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.MsgResumeHostZone;
            fromPartial(object: {
                creator?: string;
                chainId?: string;
            }): _145.MsgResumeHostZone;
        };
        MsgResumeHostZoneResponse: {
            encode(_: _145.MsgResumeHostZoneResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.MsgResumeHostZoneResponse;
            fromPartial(_: {}): _145.MsgResumeHostZoneResponse;
        };
        MsgCreateTradeRoute: {
            encode(message: _145.MsgCreateTradeRoute, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.MsgCreateTradeRoute;
            fromPartial(object: {
                authority?: string;
                hostChainId?: string;
                strideToRewardConnectionId?: string;
                strideToTradeConnectionId?: string;
                hostToRewardTransferChannelId?: string;
                rewardToTradeTransferChannelId?: string;
                tradeToHostTransferChannelId?: string;
                rewardDenomOnHost?: string;
                rewardDenomOnReward?: string;
                rewardDenomOnTrade?: string;
                hostDenomOnTrade?: string;
                hostDenomOnHost?: string;
                poolId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                maxAllowedSwapLossRate?: string;
                minSwapAmount?: string;
                maxSwapAmount?: string;
                minTransferAmount?: string;
            }): _145.MsgCreateTradeRoute;
        };
        MsgCreateTradeRouteResponse: {
            encode(_: _145.MsgCreateTradeRouteResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.MsgCreateTradeRouteResponse;
            fromPartial(_: {}): _145.MsgCreateTradeRouteResponse;
        };
        MsgDeleteTradeRoute: {
            encode(message: _145.MsgDeleteTradeRoute, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.MsgDeleteTradeRoute;
            fromPartial(object: {
                authority?: string;
                rewardDenom?: string;
                hostDenom?: string;
            }): _145.MsgDeleteTradeRoute;
        };
        MsgDeleteTradeRouteResponse: {
            encode(_: _145.MsgDeleteTradeRouteResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.MsgDeleteTradeRouteResponse;
            fromPartial(_: {}): _145.MsgDeleteTradeRouteResponse;
        };
        MsgUpdateTradeRoute: {
            encode(message: _145.MsgUpdateTradeRoute, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.MsgUpdateTradeRoute;
            fromPartial(object: {
                authority?: string;
                rewardDenom?: string;
                hostDenom?: string;
                poolId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                maxAllowedSwapLossRate?: string;
                minSwapAmount?: string;
                maxSwapAmount?: string;
                minTransferAmount?: string;
            }): _145.MsgUpdateTradeRoute;
        };
        MsgUpdateTradeRouteResponse: {
            encode(_: _145.MsgUpdateTradeRouteResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.MsgUpdateTradeRouteResponse;
            fromPartial(_: {}): _145.MsgUpdateTradeRouteResponse;
        };
        MsgSetCommunityPoolRebate: {
            encode(message: _145.MsgSetCommunityPoolRebate, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.MsgSetCommunityPoolRebate;
            fromPartial(object: {
                creator?: string;
                chainId?: string;
                rebateRate?: string;
                liquidStakedStTokenAmount?: string;
            }): _145.MsgSetCommunityPoolRebate;
        };
        MsgSetCommunityPoolRebateResponse: {
            encode(_: _145.MsgSetCommunityPoolRebateResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.MsgSetCommunityPoolRebateResponse;
            fromPartial(_: {}): _145.MsgSetCommunityPoolRebateResponse;
        };
        MsgToggleTradeController: {
            encode(message: _145.MsgToggleTradeController, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.MsgToggleTradeController;
            fromPartial(object: {
                creator?: string;
                chainId?: string;
                permissionChange?: _145.AuthzPermissionChange;
                address?: string;
            }): _145.MsgToggleTradeController;
        };
        MsgToggleTradeControllerResponse: {
            encode(_: _145.MsgToggleTradeControllerResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.MsgToggleTradeControllerResponse;
            fromPartial(_: {}): _145.MsgToggleTradeControllerResponse;
        };
        MsgUpdateHostZoneParams: {
            encode(message: _145.MsgUpdateHostZoneParams, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.MsgUpdateHostZoneParams;
            fromPartial(object: {
                authority?: string;
                chainId?: string;
                maxMessagesPerIcaTx?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
            }): _145.MsgUpdateHostZoneParams;
        };
        MsgUpdateHostZoneParamsResponse: {
            encode(_: _145.MsgUpdateHostZoneParamsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.MsgUpdateHostZoneParamsResponse;
            fromPartial(_: {}): _145.MsgUpdateHostZoneParamsResponse;
        };
        TradeConfig: {
            encode(message: _144.TradeConfig, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _144.TradeConfig;
            fromPartial(object: {
                poolId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                swapPrice?: string;
                priceUpdateTimestamp?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                maxAllowedSwapLossRate?: string;
                minSwapAmount?: string;
                maxSwapAmount?: string;
            }): _144.TradeConfig;
        };
        TradeRoute: {
            encode(message: _144.TradeRoute, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _144.TradeRoute;
            fromPartial(object: {
                rewardDenomOnHostZone?: string;
                rewardDenomOnRewardZone?: string;
                rewardDenomOnTradeZone?: string;
                hostDenomOnTradeZone?: string;
                hostDenomOnHostZone?: string;
                hostAccount?: {
                    chainId?: string;
                    type?: _140.ICAAccountType;
                    connectionId?: string;
                    address?: string;
                };
                rewardAccount?: {
                    chainId?: string;
                    type?: _140.ICAAccountType;
                    connectionId?: string;
                    address?: string;
                };
                tradeAccount?: {
                    chainId?: string;
                    type?: _140.ICAAccountType;
                    connectionId?: string;
                    address?: string;
                };
                hostToRewardChannelId?: string;
                rewardToTradeChannelId?: string;
                tradeToHostChannelId?: string;
                minTransferAmount?: string;
                tradeConfig?: {
                    poolId?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    swapPrice?: string;
                    priceUpdateTimestamp?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    maxAllowedSwapLossRate?: string;
                    minSwapAmount?: string;
                    maxSwapAmount?: string;
                };
            }): _144.TradeRoute;
        };
        QueryInterchainAccountFromAddressRequest: {
            encode(message: _143.QueryInterchainAccountFromAddressRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _143.QueryInterchainAccountFromAddressRequest;
            fromPartial(object: {
                owner?: string;
                connectionId?: string;
            }): _143.QueryInterchainAccountFromAddressRequest;
        };
        QueryInterchainAccountFromAddressResponse: {
            encode(message: _143.QueryInterchainAccountFromAddressResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _143.QueryInterchainAccountFromAddressResponse;
            fromPartial(object: {
                interchainAccountAddress?: string;
            }): _143.QueryInterchainAccountFromAddressResponse;
        };
        QueryParamsRequest: {
            encode(_: _143.QueryParamsRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _143.QueryParamsRequest;
            fromPartial(_: {}): _143.QueryParamsRequest;
        };
        QueryParamsResponse: {
            encode(message: _143.QueryParamsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _143.QueryParamsResponse;
            fromPartial(object: {
                params?: {
                    rewardsInterval?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    delegateInterval?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    depositInterval?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    redemptionRateInterval?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    strideCommission?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    reinvestInterval?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    icaTimeoutNanos?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    bufferSize?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    ibcTimeoutBlocks?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    feeTransferTimeoutNanos?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    maxStakeIcaCallsPerEpoch?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    defaultMinRedemptionRateThreshold?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    defaultMaxRedemptionRateThreshold?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    ibcTransferTimeoutNanos?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    validatorSlashQueryThreshold?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    validatorWeightCap?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                };
            }): _143.QueryParamsResponse;
        };
        QueryGetValidatorsRequest: {
            encode(message: _143.QueryGetValidatorsRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _143.QueryGetValidatorsRequest;
            fromPartial(object: {
                chainId?: string;
            }): _143.QueryGetValidatorsRequest;
        };
        QueryGetValidatorsResponse: {
            encode(message: _143.QueryGetValidatorsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _143.QueryGetValidatorsResponse;
            fromPartial(object: {
                validators?: {
                    name?: string;
                    address?: string;
                    weight?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    delegation?: string;
                    slashQueryProgressTracker?: string;
                    slashQueryCheckpoint?: string;
                    sharesToTokensRate?: string;
                    delegationChangesInProgress?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    slashQueryInProgress?: boolean;
                }[];
            }): _143.QueryGetValidatorsResponse;
        };
        QueryGetHostZoneRequest: {
            encode(message: _143.QueryGetHostZoneRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _143.QueryGetHostZoneRequest;
            fromPartial(object: {
                chainId?: string;
            }): _143.QueryGetHostZoneRequest;
        };
        QueryGetHostZoneResponse: {
            encode(message: _143.QueryGetHostZoneResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _143.QueryGetHostZoneResponse;
            fromPartial(object: {
                hostZone?: {
                    chainId?: string;
                    bech32prefix?: string;
                    connectionId?: string;
                    transferChannelId?: string;
                    ibcDenom?: string;
                    hostDenom?: string;
                    unbondingPeriod?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    validators?: {
                        name?: string;
                        address?: string;
                        weight?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        delegation?: string;
                        slashQueryProgressTracker?: string;
                        slashQueryCheckpoint?: string;
                        sharesToTokensRate?: string;
                        delegationChangesInProgress?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        slashQueryInProgress?: boolean;
                    }[];
                    depositAddress?: string;
                    withdrawalIcaAddress?: string;
                    feeIcaAddress?: string;
                    delegationIcaAddress?: string;
                    redemptionIcaAddress?: string;
                    communityPoolDepositIcaAddress?: string;
                    communityPoolReturnIcaAddress?: string;
                    communityPoolStakeHoldingAddress?: string;
                    communityPoolRedeemHoldingAddress?: string;
                    communityPoolTreasuryAddress?: string;
                    totalDelegations?: string;
                    lastRedemptionRate?: string;
                    redemptionRate?: string;
                    minRedemptionRate?: string;
                    maxRedemptionRate?: string;
                    minInnerRedemptionRate?: string;
                    maxInnerRedemptionRate?: string;
                    maxMessagesPerIcaTx?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    communityPoolRebate?: {
                        rebateRate?: string;
                        liquidStakedStTokenAmount?: string;
                    };
                    lsmLiquidStakeEnabled?: boolean;
                    halted?: boolean;
                };
            }): _143.QueryGetHostZoneResponse;
        };
        QueryAllHostZoneRequest: {
            encode(message: _143.QueryAllHostZoneRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _143.QueryAllHostZoneRequest;
            fromPartial(object: {
                pagination?: {
                    key?: Uint8Array;
                    offset?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    limit?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    countTotal?: boolean;
                    reverse?: boolean;
                };
            }): _143.QueryAllHostZoneRequest;
        };
        QueryAllHostZoneResponse: {
            encode(message: _143.QueryAllHostZoneResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _143.QueryAllHostZoneResponse;
            fromPartial(object: {
                hostZone?: {
                    chainId?: string;
                    bech32prefix?: string;
                    connectionId?: string;
                    transferChannelId?: string;
                    ibcDenom?: string;
                    hostDenom?: string;
                    unbondingPeriod?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    validators?: {
                        name?: string;
                        address?: string;
                        weight?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        delegation?: string;
                        slashQueryProgressTracker?: string;
                        slashQueryCheckpoint?: string;
                        sharesToTokensRate?: string;
                        delegationChangesInProgress?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        slashQueryInProgress?: boolean;
                    }[];
                    depositAddress?: string;
                    withdrawalIcaAddress?: string;
                    feeIcaAddress?: string;
                    delegationIcaAddress?: string;
                    redemptionIcaAddress?: string;
                    communityPoolDepositIcaAddress?: string;
                    communityPoolReturnIcaAddress?: string;
                    communityPoolStakeHoldingAddress?: string;
                    communityPoolRedeemHoldingAddress?: string;
                    communityPoolTreasuryAddress?: string;
                    totalDelegations?: string;
                    lastRedemptionRate?: string;
                    redemptionRate?: string;
                    minRedemptionRate?: string;
                    maxRedemptionRate?: string;
                    minInnerRedemptionRate?: string;
                    maxInnerRedemptionRate?: string;
                    maxMessagesPerIcaTx?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    communityPoolRebate?: {
                        rebateRate?: string;
                        liquidStakedStTokenAmount?: string;
                    };
                    lsmLiquidStakeEnabled?: boolean;
                    halted?: boolean;
                }[];
                pagination?: {
                    nextKey?: Uint8Array;
                    total?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                };
            }): _143.QueryAllHostZoneResponse;
        };
        QueryModuleAddressRequest: {
            encode(message: _143.QueryModuleAddressRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _143.QueryModuleAddressRequest;
            fromPartial(object: {
                name?: string;
            }): _143.QueryModuleAddressRequest;
        };
        QueryModuleAddressResponse: {
            encode(message: _143.QueryModuleAddressResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _143.QueryModuleAddressResponse;
            fromPartial(object: {
                addr?: string;
            }): _143.QueryModuleAddressResponse;
        };
        QueryGetEpochTrackerRequest: {
            encode(message: _143.QueryGetEpochTrackerRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _143.QueryGetEpochTrackerRequest;
            fromPartial(object: {
                epochIdentifier?: string;
            }): _143.QueryGetEpochTrackerRequest;
        };
        QueryGetEpochTrackerResponse: {
            encode(message: _143.QueryGetEpochTrackerResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _143.QueryGetEpochTrackerResponse;
            fromPartial(object: {
                epochTracker?: {
                    epochIdentifier?: string;
                    epochNumber?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    nextEpochStartTime?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    duration?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                };
            }): _143.QueryGetEpochTrackerResponse;
        };
        QueryAllEpochTrackerRequest: {
            encode(_: _143.QueryAllEpochTrackerRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _143.QueryAllEpochTrackerRequest;
            fromPartial(_: {}): _143.QueryAllEpochTrackerRequest;
        };
        QueryAllEpochTrackerResponse: {
            encode(message: _143.QueryAllEpochTrackerResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _143.QueryAllEpochTrackerResponse;
            fromPartial(object: {
                epochTracker?: {
                    epochIdentifier?: string;
                    epochNumber?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    nextEpochStartTime?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    duration?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                }[];
            }): _143.QueryAllEpochTrackerResponse;
        };
        QueryGetNextPacketSequenceRequest: {
            encode(message: _143.QueryGetNextPacketSequenceRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _143.QueryGetNextPacketSequenceRequest;
            fromPartial(object: {
                channelId?: string;
                portId?: string;
            }): _143.QueryGetNextPacketSequenceRequest;
        };
        QueryGetNextPacketSequenceResponse: {
            encode(message: _143.QueryGetNextPacketSequenceResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _143.QueryGetNextPacketSequenceResponse;
            fromPartial(object: {
                sequence?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
            }): _143.QueryGetNextPacketSequenceResponse;
        };
        QueryAddressUnbondings: {
            encode(message: _143.QueryAddressUnbondings, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _143.QueryAddressUnbondings;
            fromPartial(object: {
                address?: string;
            }): _143.QueryAddressUnbondings;
        };
        QueryAddressUnbondingsResponse: {
            encode(message: _143.QueryAddressUnbondingsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _143.QueryAddressUnbondingsResponse;
            fromPartial(object: {
                addressUnbondings?: {
                    address?: string;
                    receiver?: string;
                    unbondingEstimatedTime?: string;
                    amount?: string;
                    denom?: string;
                    claimIsPending?: boolean;
                    epochNumber?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                }[];
            }): _143.QueryAddressUnbondingsResponse;
        };
        QueryAllTradeRoutes: {
            encode(_: _143.QueryAllTradeRoutes, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _143.QueryAllTradeRoutes;
            fromPartial(_: {}): _143.QueryAllTradeRoutes;
        };
        QueryAllTradeRoutesResponse: {
            encode(message: _143.QueryAllTradeRoutesResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _143.QueryAllTradeRoutesResponse;
            fromPartial(object: {
                tradeRoutes?: {
                    rewardDenomOnHostZone?: string;
                    rewardDenomOnRewardZone?: string;
                    rewardDenomOnTradeZone?: string;
                    hostDenomOnTradeZone?: string;
                    hostDenomOnHostZone?: string;
                    hostAccount?: {
                        chainId?: string;
                        type?: _140.ICAAccountType;
                        connectionId?: string;
                        address?: string;
                    };
                    rewardAccount?: {
                        chainId?: string;
                        type?: _140.ICAAccountType;
                        connectionId?: string;
                        address?: string;
                    };
                    tradeAccount?: {
                        chainId?: string;
                        type?: _140.ICAAccountType;
                        connectionId?: string;
                        address?: string;
                    };
                    hostToRewardChannelId?: string;
                    rewardToTradeChannelId?: string;
                    tradeToHostChannelId?: string;
                    minTransferAmount?: string;
                    tradeConfig?: {
                        poolId?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        swapPrice?: string;
                        priceUpdateTimestamp?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        maxAllowedSwapLossRate?: string;
                        minSwapAmount?: string;
                        maxSwapAmount?: string;
                    };
                }[];
            }): _143.QueryAllTradeRoutesResponse;
        };
        Params: {
            encode(message: _142.Params, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _142.Params;
            fromPartial(object: {
                rewardsInterval?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                delegateInterval?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                depositInterval?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                redemptionRateInterval?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                strideCommission?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                reinvestInterval?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                icaTimeoutNanos?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                bufferSize?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                ibcTimeoutBlocks?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                feeTransferTimeoutNanos?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                maxStakeIcaCallsPerEpoch?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                defaultMinRedemptionRateThreshold?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                defaultMaxRedemptionRateThreshold?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                ibcTransferTimeoutNanos?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                validatorSlashQueryThreshold?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                validatorWeightCap?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
            }): _142.Params;
        };
        StakeibcPacketData: {
            encode(message: _141.StakeibcPacketData, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _141.StakeibcPacketData;
            fromPartial(object: {
                noData?: {};
            }): _141.StakeibcPacketData;
        };
        NoData: {
            encode(_: _141.NoData, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _141.NoData;
            fromPartial(_: {}): _141.NoData;
        };
        iCAAccountTypeFromJSON(object: any): _140.ICAAccountType;
        iCAAccountTypeToJSON(object: _140.ICAAccountType): string;
        ICAAccountType: typeof _140.ICAAccountType;
        ICAAccountTypeSDKType: typeof _140.ICAAccountTypeSDKType;
        ICAAccount: {
            encode(message: _140.ICAAccount, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _140.ICAAccount;
            fromPartial(object: {
                chainId?: string;
                type?: _140.ICAAccountType;
                connectionId?: string;
                address?: string;
            }): _140.ICAAccount;
        };
        CommunityPoolRebate: {
            encode(message: _139.CommunityPoolRebate, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _139.CommunityPoolRebate;
            fromPartial(object: {
                rebateRate?: string;
                liquidStakedStTokenAmount?: string;
            }): _139.CommunityPoolRebate;
        };
        HostZone: {
            encode(message: _139.HostZone, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _139.HostZone;
            fromPartial(object: {
                chainId?: string;
                bech32prefix?: string;
                connectionId?: string;
                transferChannelId?: string;
                ibcDenom?: string;
                hostDenom?: string;
                unbondingPeriod?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                validators?: {
                    name?: string;
                    address?: string;
                    weight?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    delegation?: string;
                    slashQueryProgressTracker?: string;
                    slashQueryCheckpoint?: string;
                    sharesToTokensRate?: string;
                    delegationChangesInProgress?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    slashQueryInProgress?: boolean;
                }[];
                depositAddress?: string;
                withdrawalIcaAddress?: string;
                feeIcaAddress?: string;
                delegationIcaAddress?: string;
                redemptionIcaAddress?: string;
                communityPoolDepositIcaAddress?: string;
                communityPoolReturnIcaAddress?: string;
                communityPoolStakeHoldingAddress?: string;
                communityPoolRedeemHoldingAddress?: string;
                communityPoolTreasuryAddress?: string;
                totalDelegations?: string;
                lastRedemptionRate?: string;
                redemptionRate?: string;
                minRedemptionRate?: string;
                maxRedemptionRate?: string;
                minInnerRedemptionRate?: string;
                maxInnerRedemptionRate?: string;
                maxMessagesPerIcaTx?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                communityPoolRebate?: {
                    rebateRate?: string;
                    liquidStakedStTokenAmount?: string;
                };
                lsmLiquidStakeEnabled?: boolean;
                halted?: boolean;
            }): _139.HostZone;
        };
        AddValidatorsProposal: {
            encode(message: _138.AddValidatorsProposal, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _138.AddValidatorsProposal;
            fromPartial(object: {
                title?: string;
                description?: string;
                hostZone?: string;
                validators?: {
                    name?: string;
                    address?: string;
                    weight?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    delegation?: string;
                    slashQueryProgressTracker?: string;
                    slashQueryCheckpoint?: string;
                    sharesToTokensRate?: string;
                    delegationChangesInProgress?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    slashQueryInProgress?: boolean;
                }[];
                deposit?: string;
            }): _138.AddValidatorsProposal;
        };
        ToggleLSMProposal: {
            encode(message: _138.ToggleLSMProposal, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _138.ToggleLSMProposal;
            fromPartial(object: {
                title?: string;
                description?: string;
                hostZone?: string;
                enabled?: boolean;
                deposit?: string;
            }): _138.ToggleLSMProposal;
        };
        GenesisState: {
            encode(message: _137.GenesisState, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _137.GenesisState;
            fromPartial(object: {
                params?: {
                    rewardsInterval?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    delegateInterval?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    depositInterval?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    redemptionRateInterval?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    strideCommission?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    reinvestInterval?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    icaTimeoutNanos?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    bufferSize?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    ibcTimeoutBlocks?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    feeTransferTimeoutNanos?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    maxStakeIcaCallsPerEpoch?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    defaultMinRedemptionRateThreshold?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    defaultMaxRedemptionRateThreshold?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    ibcTransferTimeoutNanos?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    validatorSlashQueryThreshold?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    validatorWeightCap?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                };
                portId?: string;
                hostZoneList?: {
                    chainId?: string;
                    bech32prefix?: string;
                    connectionId?: string;
                    transferChannelId?: string;
                    ibcDenom?: string;
                    hostDenom?: string;
                    unbondingPeriod?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    validators?: {
                        name?: string;
                        address?: string;
                        weight?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        delegation?: string;
                        slashQueryProgressTracker?: string;
                        slashQueryCheckpoint?: string;
                        sharesToTokensRate?: string;
                        delegationChangesInProgress?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        slashQueryInProgress?: boolean;
                    }[];
                    depositAddress?: string;
                    withdrawalIcaAddress?: string;
                    feeIcaAddress?: string;
                    delegationIcaAddress?: string;
                    redemptionIcaAddress?: string;
                    communityPoolDepositIcaAddress?: string;
                    communityPoolReturnIcaAddress?: string;
                    communityPoolStakeHoldingAddress?: string;
                    communityPoolRedeemHoldingAddress?: string;
                    communityPoolTreasuryAddress?: string;
                    totalDelegations?: string;
                    lastRedemptionRate?: string;
                    redemptionRate?: string;
                    minRedemptionRate?: string;
                    maxRedemptionRate?: string;
                    minInnerRedemptionRate?: string;
                    maxInnerRedemptionRate?: string;
                    maxMessagesPerIcaTx?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    communityPoolRebate?: {
                        rebateRate?: string;
                        liquidStakedStTokenAmount?: string;
                    };
                    lsmLiquidStakeEnabled?: boolean;
                    halted?: boolean;
                }[];
                epochTrackerList?: {
                    epochIdentifier?: string;
                    epochNumber?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    nextEpochStartTime?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    duration?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                }[];
            }): _137.GenesisState;
        };
        EpochTracker: {
            encode(message: _136.EpochTracker, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _136.EpochTracker;
            fromPartial(object: {
                epochIdentifier?: string;
                epochNumber?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                nextEpochStartTime?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                duration?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
            }): _136.EpochTracker;
        };
        SplitDelegation: {
            encode(message: _135.SplitDelegation, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _135.SplitDelegation;
            fromPartial(object: {
                validator?: string;
                amount?: string;
            }): _135.SplitDelegation;
        };
        DelegateCallback: {
            encode(message: _135.DelegateCallback, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _135.DelegateCallback;
            fromPartial(object: {
                hostZoneId?: string;
                depositRecordId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                splitDelegations?: {
                    validator?: string;
                    amount?: string;
                }[];
            }): _135.DelegateCallback;
        };
        ClaimCallback: {
            encode(message: _135.ClaimCallback, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _135.ClaimCallback;
            fromPartial(object: {
                userRedemptionRecordId?: string;
                chainId?: string;
                epochNumber?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
            }): _135.ClaimCallback;
        };
        ReinvestCallback: {
            encode(message: _135.ReinvestCallback, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _135.ReinvestCallback;
            fromPartial(object: {
                reinvestAmount?: {
                    denom?: string;
                    amount?: string;
                };
                hostZoneId?: string;
            }): _135.ReinvestCallback;
        };
        UndelegateCallback: {
            encode(message: _135.UndelegateCallback, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _135.UndelegateCallback;
            fromPartial(object: {
                hostZoneId?: string;
                splitDelegations?: {
                    validator?: string;
                    amount?: string;
                }[];
                epochUnbondingRecordIds?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                }[];
            }): _135.UndelegateCallback;
        };
        RedemptionCallback: {
            encode(message: _135.RedemptionCallback, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _135.RedemptionCallback;
            fromPartial(object: {
                hostZoneId?: string;
                epochUnbondingRecordIds?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                }[];
            }): _135.RedemptionCallback;
        };
        Rebalancing: {
            encode(message: _135.Rebalancing, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _135.Rebalancing;
            fromPartial(object: {
                srcValidator?: string;
                dstValidator?: string;
                amt?: string;
            }): _135.Rebalancing;
        };
        RebalanceCallback: {
            encode(message: _135.RebalanceCallback, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _135.RebalanceCallback;
            fromPartial(object: {
                hostZoneId?: string;
                rebalancings?: {
                    srcValidator?: string;
                    dstValidator?: string;
                    amt?: string;
                }[];
            }): _135.RebalanceCallback;
        };
        DetokenizeSharesCallback: {
            encode(message: _135.DetokenizeSharesCallback, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _135.DetokenizeSharesCallback;
            fromPartial(object: {
                deposit?: {
                    depositId?: string;
                    chainId?: string;
                    denom?: string;
                    ibcDenom?: string;
                    stakerAddress?: string;
                    validatorAddress?: string;
                    amount?: string;
                    stToken?: {
                        denom?: string;
                        amount?: string;
                    };
                    status?: _129.LSMTokenDeposit_Status;
                };
            }): _135.DetokenizeSharesCallback;
        };
        LSMLiquidStake: {
            encode(message: _135.LSMLiquidStake, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _135.LSMLiquidStake;
            fromPartial(object: {
                deposit?: {
                    depositId?: string;
                    chainId?: string;
                    denom?: string;
                    ibcDenom?: string;
                    stakerAddress?: string;
                    validatorAddress?: string;
                    amount?: string;
                    stToken?: {
                        denom?: string;
                        amount?: string;
                    };
                    status?: _129.LSMTokenDeposit_Status;
                };
                hostZone?: {
                    chainId?: string;
                    bech32prefix?: string;
                    connectionId?: string;
                    transferChannelId?: string;
                    ibcDenom?: string;
                    hostDenom?: string;
                    unbondingPeriod?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    validators?: {
                        name?: string;
                        address?: string;
                        weight?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        delegation?: string;
                        slashQueryProgressTracker?: string;
                        slashQueryCheckpoint?: string;
                        sharesToTokensRate?: string;
                        delegationChangesInProgress?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        slashQueryInProgress?: boolean;
                    }[];
                    depositAddress?: string;
                    withdrawalIcaAddress?: string;
                    feeIcaAddress?: string;
                    delegationIcaAddress?: string;
                    redemptionIcaAddress?: string;
                    communityPoolDepositIcaAddress?: string;
                    communityPoolReturnIcaAddress?: string;
                    communityPoolStakeHoldingAddress?: string;
                    communityPoolRedeemHoldingAddress?: string;
                    communityPoolTreasuryAddress?: string;
                    totalDelegations?: string;
                    lastRedemptionRate?: string;
                    redemptionRate?: string;
                    minRedemptionRate?: string;
                    maxRedemptionRate?: string;
                    minInnerRedemptionRate?: string;
                    maxInnerRedemptionRate?: string;
                    maxMessagesPerIcaTx?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    communityPoolRebate?: {
                        rebateRate?: string;
                        liquidStakedStTokenAmount?: string;
                    };
                    lsmLiquidStakeEnabled?: boolean;
                    halted?: boolean;
                };
                validator?: {
                    name?: string;
                    address?: string;
                    weight?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    delegation?: string;
                    slashQueryProgressTracker?: string;
                    slashQueryCheckpoint?: string;
                    sharesToTokensRate?: string;
                    delegationChangesInProgress?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    slashQueryInProgress?: boolean;
                };
            }): _135.LSMLiquidStake;
        };
        ValidatorSharesToTokensQueryCallback: {
            encode(message: _135.ValidatorSharesToTokensQueryCallback, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _135.ValidatorSharesToTokensQueryCallback;
            fromPartial(object: {
                lsmLiquidStake?: {
                    deposit?: {
                        depositId?: string;
                        chainId?: string;
                        denom?: string;
                        ibcDenom?: string;
                        stakerAddress?: string;
                        validatorAddress?: string;
                        amount?: string;
                        stToken?: {
                            denom?: string;
                            amount?: string;
                        };
                        status?: _129.LSMTokenDeposit_Status;
                    };
                    hostZone?: {
                        chainId?: string;
                        bech32prefix?: string;
                        connectionId?: string;
                        transferChannelId?: string;
                        ibcDenom?: string;
                        hostDenom?: string;
                        unbondingPeriod?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        validators?: {
                            name?: string;
                            address?: string;
                            weight?: {
                                high?: number;
                                low?: number;
                                unsigned?: boolean;
                                add?: (addend: string | number | import("long").default) => import("long").default;
                                and?: (other: string | number | import("long").default) => import("long").default;
                                compare?: (other: string | number | import("long").default) => number;
                                comp?: (other: string | number | import("long").default) => number;
                                divide?: (divisor: string | number | import("long").default) => import("long").default;
                                div?: (divisor: string | number | import("long").default) => import("long").default;
                                equals?: (other: string | number | import("long").default) => boolean;
                                eq?: (other: string | number | import("long").default) => boolean;
                                getHighBits?: () => number;
                                getHighBitsUnsigned?: () => number;
                                getLowBits?: () => number;
                                getLowBitsUnsigned?: () => number;
                                getNumBitsAbs?: () => number;
                                greaterThan?: (other: string | number | import("long").default) => boolean;
                                gt?: (other: string | number | import("long").default) => boolean;
                                greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                                gte?: (other: string | number | import("long").default) => boolean;
                                ge?: (other: string | number | import("long").default) => boolean;
                                isEven?: () => boolean;
                                isNegative?: () => boolean;
                                isOdd?: () => boolean;
                                isPositive?: () => boolean;
                                isZero?: () => boolean;
                                eqz?: () => boolean;
                                lessThan?: (other: string | number | import("long").default) => boolean;
                                lt?: (other: string | number | import("long").default) => boolean;
                                lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                                lte?: (other: string | number | import("long").default) => boolean;
                                le?: (other: string | number | import("long").default) => boolean;
                                modulo?: (other: string | number | import("long").default) => import("long").default;
                                mod?: (other: string | number | import("long").default) => import("long").default;
                                rem?: (other: string | number | import("long").default) => import("long").default;
                                multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                                mul?: (multiplier: string | number | import("long").default) => import("long").default;
                                negate?: () => import("long").default;
                                neg?: () => import("long").default;
                                not?: () => import("long").default;
                                countLeadingZeros?: () => number;
                                clz?: () => number;
                                countTrailingZeros?: () => number;
                                ctz?: () => number;
                                notEquals?: (other: string | number | import("long").default) => boolean;
                                neq?: (other: string | number | import("long").default) => boolean;
                                ne?: (other: string | number | import("long").default) => boolean;
                                or?: (other: string | number | import("long").default) => import("long").default;
                                shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                                shl?: (numBits: number | import("long").default) => import("long").default;
                                shiftRight?: (numBits: number | import("long").default) => import("long").default;
                                shr?: (numBits: number | import("long").default) => import("long").default;
                                shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                                shru?: (numBits: number | import("long").default) => import("long").default;
                                shr_u?: (numBits: number | import("long").default) => import("long").default;
                                rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                                rotl?: (numBits: number | import("long").default) => import("long").default;
                                rotateRight?: (numBits: number | import("long").default) => import("long").default;
                                rotr?: (numBits: number | import("long").default) => import("long").default;
                                subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                                sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                                toInt?: () => number;
                                toNumber?: () => number;
                                toBytes?: (le?: boolean) => number[];
                                toBytesLE?: () => number[];
                                toBytesBE?: () => number[];
                                toSigned?: () => import("long").default;
                                toString?: (radix?: number) => string;
                                toUnsigned?: () => import("long").default;
                                xor?: (other: string | number | import("long").default) => import("long").default;
                            };
                            delegation?: string;
                            slashQueryProgressTracker?: string;
                            slashQueryCheckpoint?: string;
                            sharesToTokensRate?: string;
                            delegationChangesInProgress?: {
                                high?: number;
                                low?: number;
                                unsigned?: boolean;
                                add?: (addend: string | number | import("long").default) => import("long").default;
                                and?: (other: string | number | import("long").default) => import("long").default;
                                compare?: (other: string | number | import("long").default) => number;
                                comp?: (other: string | number | import("long").default) => number;
                                divide?: (divisor: string | number | import("long").default) => import("long").default;
                                div?: (divisor: string | number | import("long").default) => import("long").default;
                                equals?: (other: string | number | import("long").default) => boolean;
                                eq?: (other: string | number | import("long").default) => boolean;
                                getHighBits?: () => number;
                                getHighBitsUnsigned?: () => number;
                                getLowBits?: () => number;
                                getLowBitsUnsigned?: () => number;
                                getNumBitsAbs?: () => number;
                                greaterThan?: (other: string | number | import("long").default) => boolean;
                                gt?: (other: string | number | import("long").default) => boolean;
                                greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                                gte?: (other: string | number | import("long").default) => boolean;
                                ge?: (other: string | number | import("long").default) => boolean;
                                isEven?: () => boolean;
                                isNegative?: () => boolean;
                                isOdd?: () => boolean;
                                isPositive?: () => boolean;
                                isZero?: () => boolean;
                                eqz?: () => boolean;
                                lessThan?: (other: string | number | import("long").default) => boolean;
                                lt?: (other: string | number | import("long").default) => boolean;
                                lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                                lte?: (other: string | number | import("long").default) => boolean;
                                le?: (other: string | number | import("long").default) => boolean;
                                modulo?: (other: string | number | import("long").default) => import("long").default;
                                mod?: (other: string | number | import("long").default) => import("long").default;
                                rem?: (other: string | number | import("long").default) => import("long").default;
                                multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                                mul?: (multiplier: string | number | import("long").default) => import("long").default;
                                negate?: () => import("long").default;
                                neg?: () => import("long").default;
                                not?: () => import("long").default;
                                countLeadingZeros?: () => number;
                                clz?: () => number;
                                countTrailingZeros?: () => number;
                                ctz?: () => number;
                                notEquals?: (other: string | number | import("long").default) => boolean;
                                neq?: (other: string | number | import("long").default) => boolean;
                                ne?: (other: string | number | import("long").default) => boolean;
                                or?: (other: string | number | import("long").default) => import("long").default;
                                shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                                shl?: (numBits: number | import("long").default) => import("long").default;
                                shiftRight?: (numBits: number | import("long").default) => import("long").default;
                                shr?: (numBits: number | import("long").default) => import("long").default;
                                shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                                shru?: (numBits: number | import("long").default) => import("long").default;
                                shr_u?: (numBits: number | import("long").default) => import("long").default;
                                rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                                rotl?: (numBits: number | import("long").default) => import("long").default;
                                rotateRight?: (numBits: number | import("long").default) => import("long").default;
                                rotr?: (numBits: number | import("long").default) => import("long").default;
                                subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                                sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                                toInt?: () => number;
                                toNumber?: () => number;
                                toBytes?: (le?: boolean) => number[];
                                toBytesLE?: () => number[];
                                toBytesBE?: () => number[];
                                toSigned?: () => import("long").default;
                                toString?: (radix?: number) => string;
                                toUnsigned?: () => import("long").default;
                                xor?: (other: string | number | import("long").default) => import("long").default;
                            };
                            slashQueryInProgress?: boolean;
                        }[];
                        depositAddress?: string;
                        withdrawalIcaAddress?: string;
                        feeIcaAddress?: string;
                        delegationIcaAddress?: string;
                        redemptionIcaAddress?: string;
                        communityPoolDepositIcaAddress?: string;
                        communityPoolReturnIcaAddress?: string;
                        communityPoolStakeHoldingAddress?: string;
                        communityPoolRedeemHoldingAddress?: string;
                        communityPoolTreasuryAddress?: string;
                        totalDelegations?: string;
                        lastRedemptionRate?: string;
                        redemptionRate?: string;
                        minRedemptionRate?: string;
                        maxRedemptionRate?: string;
                        minInnerRedemptionRate?: string;
                        maxInnerRedemptionRate?: string;
                        maxMessagesPerIcaTx?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        communityPoolRebate?: {
                            rebateRate?: string;
                            liquidStakedStTokenAmount?: string;
                        };
                        lsmLiquidStakeEnabled?: boolean;
                        halted?: boolean;
                    };
                    validator?: {
                        name?: string;
                        address?: string;
                        weight?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        delegation?: string;
                        slashQueryProgressTracker?: string;
                        slashQueryCheckpoint?: string;
                        sharesToTokensRate?: string;
                        delegationChangesInProgress?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        slashQueryInProgress?: boolean;
                    };
                };
            }): _135.ValidatorSharesToTokensQueryCallback;
        };
        DelegatorSharesQueryCallback: {
            encode(message: _135.DelegatorSharesQueryCallback, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _135.DelegatorSharesQueryCallback;
            fromPartial(object: {
                initialValidatorDelegation?: string;
            }): _135.DelegatorSharesQueryCallback;
        };
        CommunityPoolBalanceQueryCallback: {
            encode(message: _135.CommunityPoolBalanceQueryCallback, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _135.CommunityPoolBalanceQueryCallback;
            fromPartial(object: {
                icaType?: _140.ICAAccountType;
                denom?: string;
            }): _135.CommunityPoolBalanceQueryCallback;
        };
        TradeRouteCallback: {
            encode(message: _135.TradeRouteCallback, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _135.TradeRouteCallback;
            fromPartial(object: {
                rewardDenom?: string;
                hostDenom?: string;
            }): _135.TradeRouteCallback;
        };
        AddressUnbonding: {
            encode(message: _134.AddressUnbonding, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _134.AddressUnbonding;
            fromPartial(object: {
                address?: string;
                receiver?: string;
                unbondingEstimatedTime?: string;
                amount?: string;
                denom?: string;
                claimIsPending?: boolean;
                epochNumber?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
            }): _134.AddressUnbonding;
        };
    };
    const staketia: {
        MsgClientImpl: typeof _268.MsgClientImpl;
        QueryClientImpl: typeof _261.QueryClientImpl;
        createRpcQueryExtension: (base: import("@cosmjs/stargate").QueryClient) => {
            hostZone(request?: _148.QueryHostZoneRequest): Promise<_148.QueryHostZoneResponse>;
            delegationRecords(request: _148.QueryDelegationRecordsRequest): Promise<_148.QueryDelegationRecordsResponse>;
            unbondingRecords(request: _148.QueryUnbondingRecordsRequest): Promise<_148.QueryUnbondingRecordsResponse>;
            redemptionRecord(request: _148.QueryRedemptionRecordRequest): Promise<_148.QueryRedemptionRecordResponse>;
            redemptionRecords(request: _148.QueryRedemptionRecordsRequest): Promise<_148.QueryRedemptionRecordsResponse>;
            slashRecords(request?: _148.QuerySlashRecordsRequest): Promise<_148.QuerySlashRecordsResponse>;
        };
        LCDQueryClient: typeof _250.LCDQueryClient;
        registry: readonly [string, import("@cosmjs/proto-signing").GeneratedType][];
        load: (protoRegistry: import("@cosmjs/proto-signing").Registry) => void;
        MessageComposer: {
            encoded: {
                liquidStake(value: _150.MsgLiquidStake): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                redeemStake(value: _150.MsgRedeemStake): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                confirmDelegation(value: _150.MsgConfirmDelegation): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                confirmUndelegation(value: _150.MsgConfirmUndelegation): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                confirmUnbondedTokenSweep(value: _150.MsgConfirmUnbondedTokenSweep): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                adjustDelegatedBalance(value: _150.MsgAdjustDelegatedBalance): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                updateInnerRedemptionRateBounds(value: _150.MsgUpdateInnerRedemptionRateBounds): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                resumeHostZone(value: _150.MsgResumeHostZone): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                refreshRedemptionRate(value: _150.MsgRefreshRedemptionRate): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                overwriteDelegationRecord(value: _150.MsgOverwriteDelegationRecord): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                overwriteUnbondingRecord(value: _150.MsgOverwriteUnbondingRecord): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                overwriteRedemptionRecord(value: _150.MsgOverwriteRedemptionRecord): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                setOperatorAddress(value: _150.MsgSetOperatorAddress): {
                    typeUrl: string;
                    value: Uint8Array;
                };
            };
            withTypeUrl: {
                liquidStake(value: _150.MsgLiquidStake): {
                    typeUrl: string;
                    value: _150.MsgLiquidStake;
                };
                redeemStake(value: _150.MsgRedeemStake): {
                    typeUrl: string;
                    value: _150.MsgRedeemStake;
                };
                confirmDelegation(value: _150.MsgConfirmDelegation): {
                    typeUrl: string;
                    value: _150.MsgConfirmDelegation;
                };
                confirmUndelegation(value: _150.MsgConfirmUndelegation): {
                    typeUrl: string;
                    value: _150.MsgConfirmUndelegation;
                };
                confirmUnbondedTokenSweep(value: _150.MsgConfirmUnbondedTokenSweep): {
                    typeUrl: string;
                    value: _150.MsgConfirmUnbondedTokenSweep;
                };
                adjustDelegatedBalance(value: _150.MsgAdjustDelegatedBalance): {
                    typeUrl: string;
                    value: _150.MsgAdjustDelegatedBalance;
                };
                updateInnerRedemptionRateBounds(value: _150.MsgUpdateInnerRedemptionRateBounds): {
                    typeUrl: string;
                    value: _150.MsgUpdateInnerRedemptionRateBounds;
                };
                resumeHostZone(value: _150.MsgResumeHostZone): {
                    typeUrl: string;
                    value: _150.MsgResumeHostZone;
                };
                refreshRedemptionRate(value: _150.MsgRefreshRedemptionRate): {
                    typeUrl: string;
                    value: _150.MsgRefreshRedemptionRate;
                };
                overwriteDelegationRecord(value: _150.MsgOverwriteDelegationRecord): {
                    typeUrl: string;
                    value: _150.MsgOverwriteDelegationRecord;
                };
                overwriteUnbondingRecord(value: _150.MsgOverwriteUnbondingRecord): {
                    typeUrl: string;
                    value: _150.MsgOverwriteUnbondingRecord;
                };
                overwriteRedemptionRecord(value: _150.MsgOverwriteRedemptionRecord): {
                    typeUrl: string;
                    value: _150.MsgOverwriteRedemptionRecord;
                };
                setOperatorAddress(value: _150.MsgSetOperatorAddress): {
                    typeUrl: string;
                    value: _150.MsgSetOperatorAddress;
                };
            };
            fromPartial: {
                liquidStake(value: _150.MsgLiquidStake): {
                    typeUrl: string;
                    value: _150.MsgLiquidStake;
                };
                redeemStake(value: _150.MsgRedeemStake): {
                    typeUrl: string;
                    value: _150.MsgRedeemStake;
                };
                confirmDelegation(value: _150.MsgConfirmDelegation): {
                    typeUrl: string;
                    value: _150.MsgConfirmDelegation;
                };
                confirmUndelegation(value: _150.MsgConfirmUndelegation): {
                    typeUrl: string;
                    value: _150.MsgConfirmUndelegation;
                };
                confirmUnbondedTokenSweep(value: _150.MsgConfirmUnbondedTokenSweep): {
                    typeUrl: string;
                    value: _150.MsgConfirmUnbondedTokenSweep;
                };
                adjustDelegatedBalance(value: _150.MsgAdjustDelegatedBalance): {
                    typeUrl: string;
                    value: _150.MsgAdjustDelegatedBalance;
                };
                updateInnerRedemptionRateBounds(value: _150.MsgUpdateInnerRedemptionRateBounds): {
                    typeUrl: string;
                    value: _150.MsgUpdateInnerRedemptionRateBounds;
                };
                resumeHostZone(value: _150.MsgResumeHostZone): {
                    typeUrl: string;
                    value: _150.MsgResumeHostZone;
                };
                refreshRedemptionRate(value: _150.MsgRefreshRedemptionRate): {
                    typeUrl: string;
                    value: _150.MsgRefreshRedemptionRate;
                };
                overwriteDelegationRecord(value: _150.MsgOverwriteDelegationRecord): {
                    typeUrl: string;
                    value: _150.MsgOverwriteDelegationRecord;
                };
                overwriteUnbondingRecord(value: _150.MsgOverwriteUnbondingRecord): {
                    typeUrl: string;
                    value: _150.MsgOverwriteUnbondingRecord;
                };
                overwriteRedemptionRecord(value: _150.MsgOverwriteRedemptionRecord): {
                    typeUrl: string;
                    value: _150.MsgOverwriteRedemptionRecord;
                };
                setOperatorAddress(value: _150.MsgSetOperatorAddress): {
                    typeUrl: string;
                    value: _150.MsgSetOperatorAddress;
                };
            };
        };
        AminoConverter: {
            "/stride.staketia.MsgLiquidStake": {
                aminoType: string;
                toAmino: ({ staker, nativeAmount }: _150.MsgLiquidStake) => {
                    staker: string;
                    native_amount: string;
                };
                fromAmino: ({ staker, native_amount }: {
                    staker: string;
                    native_amount: string;
                }) => _150.MsgLiquidStake;
            };
            "/stride.staketia.MsgRedeemStake": {
                aminoType: string;
                toAmino: ({ redeemer, stTokenAmount }: _150.MsgRedeemStake) => {
                    redeemer: string;
                    st_token_amount: string;
                };
                fromAmino: ({ redeemer, st_token_amount }: {
                    redeemer: string;
                    st_token_amount: string;
                }) => _150.MsgRedeemStake;
            };
            "/stride.staketia.MsgConfirmDelegation": {
                aminoType: string;
                toAmino: ({ operator, recordId, txHash }: _150.MsgConfirmDelegation) => {
                    operator: string;
                    record_id: string;
                    tx_hash: string;
                };
                fromAmino: ({ operator, record_id, tx_hash }: {
                    operator: string;
                    record_id: string;
                    tx_hash: string;
                }) => _150.MsgConfirmDelegation;
            };
            "/stride.staketia.MsgConfirmUndelegation": {
                aminoType: string;
                toAmino: ({ operator, recordId, txHash }: _150.MsgConfirmUndelegation) => {
                    operator: string;
                    record_id: string;
                    tx_hash: string;
                };
                fromAmino: ({ operator, record_id, tx_hash }: {
                    operator: string;
                    record_id: string;
                    tx_hash: string;
                }) => _150.MsgConfirmUndelegation;
            };
            "/stride.staketia.MsgConfirmUnbondedTokenSweep": {
                aminoType: string;
                toAmino: ({ operator, recordId, txHash }: _150.MsgConfirmUnbondedTokenSweep) => {
                    operator: string;
                    record_id: string;
                    tx_hash: string;
                };
                fromAmino: ({ operator, record_id, tx_hash }: {
                    operator: string;
                    record_id: string;
                    tx_hash: string;
                }) => _150.MsgConfirmUnbondedTokenSweep;
            };
            "/stride.staketia.MsgAdjustDelegatedBalance": {
                aminoType: string;
                toAmino: ({ operator, delegationOffset, validatorAddress }: _150.MsgAdjustDelegatedBalance) => {
                    operator: string;
                    delegation_offset: string;
                    validator_address: string;
                };
                fromAmino: ({ operator, delegation_offset, validator_address }: {
                    operator: string;
                    delegation_offset: string;
                    validator_address: string;
                }) => _150.MsgAdjustDelegatedBalance;
            };
            "/stride.staketia.MsgUpdateInnerRedemptionRateBounds": {
                aminoType: string;
                toAmino: ({ creator, minInnerRedemptionRate, maxInnerRedemptionRate }: _150.MsgUpdateInnerRedemptionRateBounds) => {
                    creator: string;
                    min_inner_redemption_rate: string;
                    max_inner_redemption_rate: string;
                };
                fromAmino: ({ creator, min_inner_redemption_rate, max_inner_redemption_rate }: {
                    creator: string;
                    min_inner_redemption_rate: string;
                    max_inner_redemption_rate: string;
                }) => _150.MsgUpdateInnerRedemptionRateBounds;
            };
            "/stride.staketia.MsgResumeHostZone": {
                aminoType: string;
                toAmino: ({ creator }: _150.MsgResumeHostZone) => {
                    creator: string;
                };
                fromAmino: ({ creator }: {
                    creator: string;
                }) => _150.MsgResumeHostZone;
            };
            "/stride.staketia.MsgRefreshRedemptionRate": {
                aminoType: string;
                toAmino: ({ creator }: _150.MsgRefreshRedemptionRate) => {
                    creator: string;
                };
                fromAmino: ({ creator }: {
                    creator: string;
                }) => _150.MsgRefreshRedemptionRate;
            };
            "/stride.staketia.MsgOverwriteDelegationRecord": {
                aminoType: string;
                toAmino: ({ creator, delegationRecord }: _150.MsgOverwriteDelegationRecord) => {
                    creator: string;
                    delegation_record: {
                        id: string;
                        native_amount: string;
                        status: number;
                        tx_hash: string;
                    };
                };
                fromAmino: ({ creator, delegation_record }: {
                    creator: string;
                    delegation_record: {
                        id: string;
                        native_amount: string;
                        status: number;
                        tx_hash: string;
                    };
                }) => _150.MsgOverwriteDelegationRecord;
            };
            "/stride.staketia.MsgOverwriteUnbondingRecord": {
                aminoType: string;
                toAmino: ({ creator, unbondingRecord }: _150.MsgOverwriteUnbondingRecord) => {
                    creator: string;
                    unbonding_record: {
                        id: string;
                        status: number;
                        st_token_amount: string;
                        native_amount: string;
                        unbonding_completion_time_seconds: string;
                        undelegation_tx_hash: string;
                        unbonded_token_sweep_tx_hash: string;
                    };
                };
                fromAmino: ({ creator, unbonding_record }: {
                    creator: string;
                    unbonding_record: {
                        id: string;
                        status: number;
                        st_token_amount: string;
                        native_amount: string;
                        unbonding_completion_time_seconds: string;
                        undelegation_tx_hash: string;
                        unbonded_token_sweep_tx_hash: string;
                    };
                }) => _150.MsgOverwriteUnbondingRecord;
            };
            "/stride.staketia.MsgOverwriteRedemptionRecord": {
                aminoType: string;
                toAmino: ({ creator, redemptionRecord }: _150.MsgOverwriteRedemptionRecord) => {
                    creator: string;
                    redemption_record: {
                        unbonding_record_id: string;
                        redeemer: string;
                        st_token_amount: string;
                        native_amount: string;
                    };
                };
                fromAmino: ({ creator, redemption_record }: {
                    creator: string;
                    redemption_record: {
                        unbonding_record_id: string;
                        redeemer: string;
                        st_token_amount: string;
                        native_amount: string;
                    };
                }) => _150.MsgOverwriteRedemptionRecord;
            };
            "/stride.staketia.MsgSetOperatorAddress": {
                aminoType: string;
                toAmino: ({ signer, operator }: _150.MsgSetOperatorAddress) => {
                    signer: string;
                    operator: string;
                };
                fromAmino: ({ signer, operator }: {
                    signer: string;
                    operator: string;
                }) => _150.MsgSetOperatorAddress;
            };
        };
        overwritableRecordTypeFromJSON(object: any): _150.OverwritableRecordType;
        overwritableRecordTypeToJSON(object: _150.OverwritableRecordType): string;
        OverwritableRecordType: typeof _150.OverwritableRecordType;
        OverwritableRecordTypeSDKType: typeof _150.OverwritableRecordTypeSDKType;
        MsgLiquidStake: {
            encode(message: _150.MsgLiquidStake, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _150.MsgLiquidStake;
            fromPartial(object: {
                staker?: string;
                nativeAmount?: string;
            }): _150.MsgLiquidStake;
        };
        MsgLiquidStakeResponse: {
            encode(message: _150.MsgLiquidStakeResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _150.MsgLiquidStakeResponse;
            fromPartial(object: {
                stToken?: {
                    denom?: string;
                    amount?: string;
                };
            }): _150.MsgLiquidStakeResponse;
        };
        MsgRedeemStake: {
            encode(message: _150.MsgRedeemStake, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _150.MsgRedeemStake;
            fromPartial(object: {
                redeemer?: string;
                stTokenAmount?: string;
            }): _150.MsgRedeemStake;
        };
        MsgRedeemStakeResponse: {
            encode(message: _150.MsgRedeemStakeResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _150.MsgRedeemStakeResponse;
            fromPartial(object: {
                nativeToken?: {
                    denom?: string;
                    amount?: string;
                };
            }): _150.MsgRedeemStakeResponse;
        };
        MsgConfirmDelegation: {
            encode(message: _150.MsgConfirmDelegation, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _150.MsgConfirmDelegation;
            fromPartial(object: {
                operator?: string;
                recordId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                txHash?: string;
            }): _150.MsgConfirmDelegation;
        };
        MsgConfirmDelegationResponse: {
            encode(_: _150.MsgConfirmDelegationResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _150.MsgConfirmDelegationResponse;
            fromPartial(_: {}): _150.MsgConfirmDelegationResponse;
        };
        MsgConfirmUndelegation: {
            encode(message: _150.MsgConfirmUndelegation, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _150.MsgConfirmUndelegation;
            fromPartial(object: {
                operator?: string;
                recordId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                txHash?: string;
            }): _150.MsgConfirmUndelegation;
        };
        MsgConfirmUndelegationResponse: {
            encode(_: _150.MsgConfirmUndelegationResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _150.MsgConfirmUndelegationResponse;
            fromPartial(_: {}): _150.MsgConfirmUndelegationResponse;
        };
        MsgConfirmUnbondedTokenSweep: {
            encode(message: _150.MsgConfirmUnbondedTokenSweep, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _150.MsgConfirmUnbondedTokenSweep;
            fromPartial(object: {
                operator?: string;
                recordId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                txHash?: string;
            }): _150.MsgConfirmUnbondedTokenSweep;
        };
        MsgConfirmUnbondedTokenSweepResponse: {
            encode(_: _150.MsgConfirmUnbondedTokenSweepResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _150.MsgConfirmUnbondedTokenSweepResponse;
            fromPartial(_: {}): _150.MsgConfirmUnbondedTokenSweepResponse;
        };
        MsgAdjustDelegatedBalance: {
            encode(message: _150.MsgAdjustDelegatedBalance, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _150.MsgAdjustDelegatedBalance;
            fromPartial(object: {
                operator?: string;
                delegationOffset?: string;
                validatorAddress?: string;
            }): _150.MsgAdjustDelegatedBalance;
        };
        MsgAdjustDelegatedBalanceResponse: {
            encode(_: _150.MsgAdjustDelegatedBalanceResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _150.MsgAdjustDelegatedBalanceResponse;
            fromPartial(_: {}): _150.MsgAdjustDelegatedBalanceResponse;
        };
        MsgUpdateInnerRedemptionRateBounds: {
            encode(message: _150.MsgUpdateInnerRedemptionRateBounds, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _150.MsgUpdateInnerRedemptionRateBounds;
            fromPartial(object: {
                creator?: string;
                minInnerRedemptionRate?: string;
                maxInnerRedemptionRate?: string;
            }): _150.MsgUpdateInnerRedemptionRateBounds;
        };
        MsgUpdateInnerRedemptionRateBoundsResponse: {
            encode(_: _150.MsgUpdateInnerRedemptionRateBoundsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _150.MsgUpdateInnerRedemptionRateBoundsResponse;
            fromPartial(_: {}): _150.MsgUpdateInnerRedemptionRateBoundsResponse;
        };
        MsgResumeHostZone: {
            encode(message: _150.MsgResumeHostZone, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _150.MsgResumeHostZone;
            fromPartial(object: {
                creator?: string;
            }): _150.MsgResumeHostZone;
        };
        MsgResumeHostZoneResponse: {
            encode(_: _150.MsgResumeHostZoneResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _150.MsgResumeHostZoneResponse;
            fromPartial(_: {}): _150.MsgResumeHostZoneResponse;
        };
        MsgRefreshRedemptionRate: {
            encode(message: _150.MsgRefreshRedemptionRate, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _150.MsgRefreshRedemptionRate;
            fromPartial(object: {
                creator?: string;
            }): _150.MsgRefreshRedemptionRate;
        };
        MsgRefreshRedemptionRateResponse: {
            encode(_: _150.MsgRefreshRedemptionRateResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _150.MsgRefreshRedemptionRateResponse;
            fromPartial(_: {}): _150.MsgRefreshRedemptionRateResponse;
        };
        MsgOverwriteDelegationRecord: {
            encode(message: _150.MsgOverwriteDelegationRecord, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _150.MsgOverwriteDelegationRecord;
            fromPartial(object: {
                creator?: string;
                delegationRecord?: {
                    id?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    nativeAmount?: string;
                    status?: _149.DelegationRecordStatus;
                    txHash?: string;
                };
            }): _150.MsgOverwriteDelegationRecord;
        };
        MsgOverwriteDelegationRecordResponse: {
            encode(_: _150.MsgOverwriteDelegationRecordResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _150.MsgOverwriteDelegationRecordResponse;
            fromPartial(_: {}): _150.MsgOverwriteDelegationRecordResponse;
        };
        MsgOverwriteUnbondingRecord: {
            encode(message: _150.MsgOverwriteUnbondingRecord, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _150.MsgOverwriteUnbondingRecord;
            fromPartial(object: {
                creator?: string;
                unbondingRecord?: {
                    id?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    status?: _149.UnbondingRecordStatus;
                    stTokenAmount?: string;
                    nativeAmount?: string;
                    unbondingCompletionTimeSeconds?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    undelegationTxHash?: string;
                    unbondedTokenSweepTxHash?: string;
                };
            }): _150.MsgOverwriteUnbondingRecord;
        };
        MsgOverwriteUnbondingRecordResponse: {
            encode(_: _150.MsgOverwriteUnbondingRecordResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _150.MsgOverwriteUnbondingRecordResponse;
            fromPartial(_: {}): _150.MsgOverwriteUnbondingRecordResponse;
        };
        MsgOverwriteRedemptionRecord: {
            encode(message: _150.MsgOverwriteRedemptionRecord, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _150.MsgOverwriteRedemptionRecord;
            fromPartial(object: {
                creator?: string;
                redemptionRecord?: {
                    unbondingRecordId?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    redeemer?: string;
                    stTokenAmount?: string;
                    nativeAmount?: string;
                };
            }): _150.MsgOverwriteRedemptionRecord;
        };
        MsgOverwriteRedemptionRecordResponse: {
            encode(_: _150.MsgOverwriteRedemptionRecordResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _150.MsgOverwriteRedemptionRecordResponse;
            fromPartial(_: {}): _150.MsgOverwriteRedemptionRecordResponse;
        };
        MsgSetOperatorAddress: {
            encode(message: _150.MsgSetOperatorAddress, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _150.MsgSetOperatorAddress;
            fromPartial(object: {
                signer?: string;
                operator?: string;
            }): _150.MsgSetOperatorAddress;
        };
        MsgSetOperatorAddressResponse: {
            encode(_: _150.MsgSetOperatorAddressResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _150.MsgSetOperatorAddressResponse;
            fromPartial(_: {}): _150.MsgSetOperatorAddressResponse;
        };
        delegationRecordStatusFromJSON(object: any): _149.DelegationRecordStatus;
        delegationRecordStatusToJSON(object: _149.DelegationRecordStatus): string;
        unbondingRecordStatusFromJSON(object: any): _149.UnbondingRecordStatus;
        unbondingRecordStatusToJSON(object: _149.UnbondingRecordStatus): string;
        DelegationRecordStatus: typeof _149.DelegationRecordStatus;
        DelegationRecordStatusSDKType: typeof _149.DelegationRecordStatusSDKType;
        UnbondingRecordStatus: typeof _149.UnbondingRecordStatus;
        UnbondingRecordStatusSDKType: typeof _149.UnbondingRecordStatusSDKType;
        HostZone: {
            encode(message: _149.HostZone, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _149.HostZone;
            fromPartial(object: {
                chainId?: string;
                nativeTokenDenom?: string;
                nativeTokenIbcDenom?: string;
                transferChannelId?: string;
                delegationAddress?: string;
                rewardAddress?: string;
                depositAddress?: string;
                redemptionAddress?: string;
                claimAddress?: string;
                operatorAddressOnStride?: string;
                safeAddressOnStride?: string;
                lastRedemptionRate?: string;
                redemptionRate?: string;
                minRedemptionRate?: string;
                maxRedemptionRate?: string;
                minInnerRedemptionRate?: string;
                maxInnerRedemptionRate?: string;
                delegatedBalance?: string;
                unbondingPeriodSeconds?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                halted?: boolean;
            }): _149.HostZone;
        };
        DelegationRecord: {
            encode(message: _149.DelegationRecord, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _149.DelegationRecord;
            fromPartial(object: {
                id?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                nativeAmount?: string;
                status?: _149.DelegationRecordStatus;
                txHash?: string;
            }): _149.DelegationRecord;
        };
        UnbondingRecord: {
            encode(message: _149.UnbondingRecord, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _149.UnbondingRecord;
            fromPartial(object: {
                id?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                status?: _149.UnbondingRecordStatus;
                stTokenAmount?: string;
                nativeAmount?: string;
                unbondingCompletionTimeSeconds?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                undelegationTxHash?: string;
                unbondedTokenSweepTxHash?: string;
            }): _149.UnbondingRecord;
        };
        RedemptionRecord: {
            encode(message: _149.RedemptionRecord, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _149.RedemptionRecord;
            fromPartial(object: {
                unbondingRecordId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                redeemer?: string;
                stTokenAmount?: string;
                nativeAmount?: string;
            }): _149.RedemptionRecord;
        };
        SlashRecord: {
            encode(message: _149.SlashRecord, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _149.SlashRecord;
            fromPartial(object: {
                id?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                time?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                nativeAmount?: string;
                validatorAddress?: string;
            }): _149.SlashRecord;
        };
        QueryHostZoneRequest: {
            encode(_: _148.QueryHostZoneRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _148.QueryHostZoneRequest;
            fromPartial(_: {}): _148.QueryHostZoneRequest;
        };
        QueryHostZoneResponse: {
            encode(message: _148.QueryHostZoneResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _148.QueryHostZoneResponse;
            fromPartial(object: {
                hostZone?: {
                    chainId?: string;
                    nativeTokenDenom?: string;
                    nativeTokenIbcDenom?: string;
                    transferChannelId?: string;
                    delegationAddress?: string;
                    rewardAddress?: string;
                    depositAddress?: string;
                    redemptionAddress?: string;
                    claimAddress?: string;
                    operatorAddressOnStride?: string;
                    safeAddressOnStride?: string;
                    lastRedemptionRate?: string;
                    redemptionRate?: string;
                    minRedemptionRate?: string;
                    maxRedemptionRate?: string;
                    minInnerRedemptionRate?: string;
                    maxInnerRedemptionRate?: string;
                    delegatedBalance?: string;
                    unbondingPeriodSeconds?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    halted?: boolean;
                };
            }): _148.QueryHostZoneResponse;
        };
        QueryDelegationRecordsRequest: {
            encode(message: _148.QueryDelegationRecordsRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _148.QueryDelegationRecordsRequest;
            fromPartial(object: {
                includeArchived?: boolean;
            }): _148.QueryDelegationRecordsRequest;
        };
        QueryDelegationRecordsResponse: {
            encode(message: _148.QueryDelegationRecordsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _148.QueryDelegationRecordsResponse;
            fromPartial(object: {
                delegationRecords?: {
                    id?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    nativeAmount?: string;
                    status?: _149.DelegationRecordStatus;
                    txHash?: string;
                }[];
            }): _148.QueryDelegationRecordsResponse;
        };
        QueryUnbondingRecordsRequest: {
            encode(message: _148.QueryUnbondingRecordsRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _148.QueryUnbondingRecordsRequest;
            fromPartial(object: {
                includeArchived?: boolean;
            }): _148.QueryUnbondingRecordsRequest;
        };
        QueryUnbondingRecordsResponse: {
            encode(message: _148.QueryUnbondingRecordsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _148.QueryUnbondingRecordsResponse;
            fromPartial(object: {
                unbondingRecords?: {
                    id?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    status?: _149.UnbondingRecordStatus;
                    stTokenAmount?: string;
                    nativeAmount?: string;
                    unbondingCompletionTimeSeconds?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    undelegationTxHash?: string;
                    unbondedTokenSweepTxHash?: string;
                }[];
            }): _148.QueryUnbondingRecordsResponse;
        };
        QueryRedemptionRecordRequest: {
            encode(message: _148.QueryRedemptionRecordRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _148.QueryRedemptionRecordRequest;
            fromPartial(object: {
                unbondingRecordId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                address?: string;
            }): _148.QueryRedemptionRecordRequest;
        };
        QueryRedemptionRecordResponse: {
            encode(message: _148.QueryRedemptionRecordResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _148.QueryRedemptionRecordResponse;
            fromPartial(object: {
                redemptionRecordResponse?: {
                    redemptionRecord?: {
                        unbondingRecordId?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        redeemer?: string;
                        stTokenAmount?: string;
                        nativeAmount?: string;
                    };
                    unbondingCompletionTimeSeconds?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                };
            }): _148.QueryRedemptionRecordResponse;
        };
        QueryRedemptionRecordsRequest: {
            encode(message: _148.QueryRedemptionRecordsRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _148.QueryRedemptionRecordsRequest;
            fromPartial(object: {
                address?: string;
                unbondingRecordId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                pagination?: {
                    key?: Uint8Array;
                    offset?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    limit?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    countTotal?: boolean;
                    reverse?: boolean;
                };
            }): _148.QueryRedemptionRecordsRequest;
        };
        QueryRedemptionRecordsResponse: {
            encode(message: _148.QueryRedemptionRecordsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _148.QueryRedemptionRecordsResponse;
            fromPartial(object: {
                redemptionRecordResponses?: {
                    redemptionRecord?: {
                        unbondingRecordId?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        redeemer?: string;
                        stTokenAmount?: string;
                        nativeAmount?: string;
                    };
                    unbondingCompletionTimeSeconds?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                }[];
                pagination?: {
                    nextKey?: Uint8Array;
                    total?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                };
            }): _148.QueryRedemptionRecordsResponse;
        };
        QuerySlashRecordsRequest: {
            encode(_: _148.QuerySlashRecordsRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _148.QuerySlashRecordsRequest;
            fromPartial(_: {}): _148.QuerySlashRecordsRequest;
        };
        QuerySlashRecordsResponse: {
            encode(message: _148.QuerySlashRecordsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _148.QuerySlashRecordsResponse;
            fromPartial(object: {
                slashRecords?: {
                    id?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    time?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    nativeAmount?: string;
                    validatorAddress?: string;
                }[];
            }): _148.QuerySlashRecordsResponse;
        };
        RedemptionRecordResponse: {
            encode(message: _148.RedemptionRecordResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _148.RedemptionRecordResponse;
            fromPartial(object: {
                redemptionRecord?: {
                    unbondingRecordId?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    redeemer?: string;
                    stTokenAmount?: string;
                    nativeAmount?: string;
                };
                unbondingCompletionTimeSeconds?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
            }): _148.RedemptionRecordResponse;
        };
        Params: {
            encode(_: _147.Params, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _147.Params;
            fromPartial(_: {}): _147.Params;
        };
        TransferInProgressRecordIds: {
            encode(message: _147.TransferInProgressRecordIds, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _147.TransferInProgressRecordIds;
            fromPartial(object: {
                channelId?: string;
                sequence?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                recordId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
            }): _147.TransferInProgressRecordIds;
        };
        GenesisState: {
            encode(message: _147.GenesisState, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _147.GenesisState;
            fromPartial(object: {
                params?: {};
                hostZone?: {
                    chainId?: string;
                    nativeTokenDenom?: string;
                    nativeTokenIbcDenom?: string;
                    transferChannelId?: string;
                    delegationAddress?: string;
                    rewardAddress?: string;
                    depositAddress?: string;
                    redemptionAddress?: string;
                    claimAddress?: string;
                    operatorAddressOnStride?: string;
                    safeAddressOnStride?: string;
                    lastRedemptionRate?: string;
                    redemptionRate?: string;
                    minRedemptionRate?: string;
                    maxRedemptionRate?: string;
                    minInnerRedemptionRate?: string;
                    maxInnerRedemptionRate?: string;
                    delegatedBalance?: string;
                    unbondingPeriodSeconds?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    halted?: boolean;
                };
                delegationRecords?: {
                    id?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    nativeAmount?: string;
                    status?: _149.DelegationRecordStatus;
                    txHash?: string;
                }[];
                unbondingRecords?: {
                    id?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    status?: _149.UnbondingRecordStatus;
                    stTokenAmount?: string;
                    nativeAmount?: string;
                    unbondingCompletionTimeSeconds?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    undelegationTxHash?: string;
                    unbondedTokenSweepTxHash?: string;
                }[];
                redemptionRecords?: {
                    unbondingRecordId?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    redeemer?: string;
                    stTokenAmount?: string;
                    nativeAmount?: string;
                }[];
                slashRecords?: {
                    id?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    time?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    nativeAmount?: string;
                    validatorAddress?: string;
                }[];
                transferInProgressRecordIds?: {
                    channelId?: string;
                    sequence?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    recordId?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                }[];
            }): _147.GenesisState;
        };
    };
    const vesting: {
        BaseVestingAccount: {
            encode(message: _152.BaseVestingAccount, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _152.BaseVestingAccount;
            fromPartial(object: {
                baseAccount?: {
                    address?: string;
                    pubKey?: {
                        typeUrl?: string;
                        value?: Uint8Array;
                    };
                    accountNumber?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    sequence?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                };
                originalVesting?: {
                    denom?: string;
                    amount?: string;
                }[];
                delegatedFree?: {
                    denom?: string;
                    amount?: string;
                }[];
                delegatedVesting?: {
                    denom?: string;
                    amount?: string;
                }[];
                endTime?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
            }): _152.BaseVestingAccount;
        };
        Period: {
            encode(message: _152.Period, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _152.Period;
            fromPartial(object: {
                startTime?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                length?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long").default) => import("long").default;
                    and?: (other: string | number | import("long").default) => import("long").default;
                    compare?: (other: string | number | import("long").default) => number;
                    comp?: (other: string | number | import("long").default) => number;
                    divide?: (divisor: string | number | import("long").default) => import("long").default;
                    div?: (divisor: string | number | import("long").default) => import("long").default;
                    equals?: (other: string | number | import("long").default) => boolean;
                    eq?: (other: string | number | import("long").default) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long").default) => boolean;
                    gt?: (other: string | number | import("long").default) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    gte?: (other: string | number | import("long").default) => boolean;
                    ge?: (other: string | number | import("long").default) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long").default) => boolean;
                    lt?: (other: string | number | import("long").default) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                    lte?: (other: string | number | import("long").default) => boolean;
                    le?: (other: string | number | import("long").default) => boolean;
                    modulo?: (other: string | number | import("long").default) => import("long").default;
                    mod?: (other: string | number | import("long").default) => import("long").default;
                    rem?: (other: string | number | import("long").default) => import("long").default;
                    multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                    mul?: (multiplier: string | number | import("long").default) => import("long").default;
                    negate?: () => import("long").default;
                    neg?: () => import("long").default;
                    not?: () => import("long").default;
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long").default) => boolean;
                    neq?: (other: string | number | import("long").default) => boolean;
                    ne?: (other: string | number | import("long").default) => boolean;
                    or?: (other: string | number | import("long").default) => import("long").default;
                    shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                    shl?: (numBits: number | import("long").default) => import("long").default;
                    shiftRight?: (numBits: number | import("long").default) => import("long").default;
                    shr?: (numBits: number | import("long").default) => import("long").default;
                    shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                    shru?: (numBits: number | import("long").default) => import("long").default;
                    shr_u?: (numBits: number | import("long").default) => import("long").default;
                    rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                    rotl?: (numBits: number | import("long").default) => import("long").default;
                    rotateRight?: (numBits: number | import("long").default) => import("long").default;
                    rotr?: (numBits: number | import("long").default) => import("long").default;
                    subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                    sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long").default;
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long").default;
                    xor?: (other: string | number | import("long").default) => import("long").default;
                };
                amount?: {
                    denom?: string;
                    amount?: string;
                }[];
                actionType?: number;
            }): _152.Period;
        };
        StridePeriodicVestingAccount: {
            encode(message: _152.StridePeriodicVestingAccount, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _152.StridePeriodicVestingAccount;
            fromPartial(object: {
                baseVestingAccount?: {
                    baseAccount?: {
                        address?: string;
                        pubKey?: {
                            typeUrl?: string;
                            value?: Uint8Array;
                        };
                        accountNumber?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                        sequence?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long").default) => import("long").default;
                            and?: (other: string | number | import("long").default) => import("long").default;
                            compare?: (other: string | number | import("long").default) => number;
                            comp?: (other: string | number | import("long").default) => number;
                            divide?: (divisor: string | number | import("long").default) => import("long").default;
                            div?: (divisor: string | number | import("long").default) => import("long").default;
                            equals?: (other: string | number | import("long").default) => boolean;
                            eq?: (other: string | number | import("long").default) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long").default) => boolean;
                            gt?: (other: string | number | import("long").default) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            gte?: (other: string | number | import("long").default) => boolean;
                            ge?: (other: string | number | import("long").default) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long").default) => boolean;
                            lt?: (other: string | number | import("long").default) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                            lte?: (other: string | number | import("long").default) => boolean;
                            le?: (other: string | number | import("long").default) => boolean;
                            modulo?: (other: string | number | import("long").default) => import("long").default;
                            mod?: (other: string | number | import("long").default) => import("long").default;
                            rem?: (other: string | number | import("long").default) => import("long").default;
                            multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                            mul?: (multiplier: string | number | import("long").default) => import("long").default;
                            negate?: () => import("long").default;
                            neg?: () => import("long").default;
                            not?: () => import("long").default;
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long").default) => boolean;
                            neq?: (other: string | number | import("long").default) => boolean;
                            ne?: (other: string | number | import("long").default) => boolean;
                            or?: (other: string | number | import("long").default) => import("long").default;
                            shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                            shl?: (numBits: number | import("long").default) => import("long").default;
                            shiftRight?: (numBits: number | import("long").default) => import("long").default;
                            shr?: (numBits: number | import("long").default) => import("long").default;
                            shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                            shru?: (numBits: number | import("long").default) => import("long").default;
                            shr_u?: (numBits: number | import("long").default) => import("long").default;
                            rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                            rotl?: (numBits: number | import("long").default) => import("long").default;
                            rotateRight?: (numBits: number | import("long").default) => import("long").default;
                            rotr?: (numBits: number | import("long").default) => import("long").default;
                            subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                            sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long").default;
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long").default;
                            xor?: (other: string | number | import("long").default) => import("long").default;
                        };
                    };
                    originalVesting?: {
                        denom?: string;
                        amount?: string;
                    }[];
                    delegatedFree?: {
                        denom?: string;
                        amount?: string;
                    }[];
                    delegatedVesting?: {
                        denom?: string;
                        amount?: string;
                    }[];
                    endTime?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                };
                vestingPeriods?: {
                    startTime?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    length?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long").default) => import("long").default;
                        and?: (other: string | number | import("long").default) => import("long").default;
                        compare?: (other: string | number | import("long").default) => number;
                        comp?: (other: string | number | import("long").default) => number;
                        divide?: (divisor: string | number | import("long").default) => import("long").default;
                        div?: (divisor: string | number | import("long").default) => import("long").default;
                        equals?: (other: string | number | import("long").default) => boolean;
                        eq?: (other: string | number | import("long").default) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long").default) => boolean;
                        gt?: (other: string | number | import("long").default) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        gte?: (other: string | number | import("long").default) => boolean;
                        ge?: (other: string | number | import("long").default) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long").default) => boolean;
                        lt?: (other: string | number | import("long").default) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long").default) => boolean;
                        lte?: (other: string | number | import("long").default) => boolean;
                        le?: (other: string | number | import("long").default) => boolean;
                        modulo?: (other: string | number | import("long").default) => import("long").default;
                        mod?: (other: string | number | import("long").default) => import("long").default;
                        rem?: (other: string | number | import("long").default) => import("long").default;
                        multiply?: (multiplier: string | number | import("long").default) => import("long").default;
                        mul?: (multiplier: string | number | import("long").default) => import("long").default;
                        negate?: () => import("long").default;
                        neg?: () => import("long").default;
                        not?: () => import("long").default;
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long").default) => boolean;
                        neq?: (other: string | number | import("long").default) => boolean;
                        ne?: (other: string | number | import("long").default) => boolean;
                        or?: (other: string | number | import("long").default) => import("long").default;
                        shiftLeft?: (numBits: number | import("long").default) => import("long").default;
                        shl?: (numBits: number | import("long").default) => import("long").default;
                        shiftRight?: (numBits: number | import("long").default) => import("long").default;
                        shr?: (numBits: number | import("long").default) => import("long").default;
                        shiftRightUnsigned?: (numBits: number | import("long").default) => import("long").default;
                        shru?: (numBits: number | import("long").default) => import("long").default;
                        shr_u?: (numBits: number | import("long").default) => import("long").default;
                        rotateLeft?: (numBits: number | import("long").default) => import("long").default;
                        rotl?: (numBits: number | import("long").default) => import("long").default;
                        rotateRight?: (numBits: number | import("long").default) => import("long").default;
                        rotr?: (numBits: number | import("long").default) => import("long").default;
                        subtract?: (subtrahend: string | number | import("long").default) => import("long").default;
                        sub?: (subtrahend: string | number | import("long").default) => import("long").default;
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long").default;
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long").default;
                        xor?: (other: string | number | import("long").default) => import("long").default;
                    };
                    amount?: {
                        denom?: string;
                        amount?: string;
                    }[];
                    actionType?: number;
                }[];
            }): _152.StridePeriodicVestingAccount;
        };
    };
    const ClientFactory: {
        createRPCMsgClient: ({ rpc }: {
            rpc: import("@osmonauts/helpers").Rpc;
        }) => Promise<{
            cosmos: {
                authz: {
                    v1beta1: import("../cosmos/authz/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
                bank: {
                    v1beta1: import("../cosmos/bank/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
                crisis: {
                    v1beta1: import("../cosmos/crisis/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
                distribution: {
                    v1beta1: import("../cosmos/distribution/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
                evidence: {
                    v1beta1: import("../cosmos/evidence/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
                feegrant: {
                    v1beta1: import("../cosmos/feegrant/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
                gov: {
                    v1beta1: import("../cosmos/gov/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
                slashing: {
                    v1beta1: import("../cosmos/slashing/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
                staking: {
                    v1beta1: import("../cosmos/staking/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
                vesting: {
                    v1beta1: import("../cosmos/vesting/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
            };
            stride: {
                airdrop: _262.MsgClientImpl;
                claim: _263.MsgClientImpl;
                icaoracle: _264.MsgClientImpl;
                interchainquery: {
                    v1: _265.MsgClientImpl;
                };
                stakedym: _266.MsgClientImpl;
                stakeibc: _267.MsgClientImpl;
                staketia: _268.MsgClientImpl;
            };
        }>;
        createRPCQueryClient: ({ rpcEndpoint }: {
            rpcEndpoint: string;
        }) => Promise<{
            cosmos: {
                auth: {
                    v1beta1: {
                        accounts(request?: import("../cosmos/auth/v1beta1/query").QueryAccountsRequest): Promise<import("../cosmos/auth/v1beta1/query").QueryAccountsResponse>;
                        account(request: import("../cosmos/auth/v1beta1/query").QueryAccountRequest): Promise<import("../cosmos/auth/v1beta1/query").QueryAccountResponse>;
                        params(request?: import("../cosmos/auth/v1beta1/query").QueryParamsRequest): Promise<import("../cosmos/auth/v1beta1/query").QueryParamsResponse>;
                        moduleAccountByName(request: import("../cosmos/auth/v1beta1/query").QueryModuleAccountByNameRequest): Promise<import("../cosmos/auth/v1beta1/query").QueryModuleAccountByNameResponse>;
                    };
                };
                authz: {
                    v1beta1: {
                        grants(request: import("../cosmos/authz/v1beta1/query").QueryGrantsRequest): Promise<import("../cosmos/authz/v1beta1/query").QueryGrantsResponse>;
                        granterGrants(request: import("../cosmos/authz/v1beta1/query").QueryGranterGrantsRequest): Promise<import("../cosmos/authz/v1beta1/query").QueryGranterGrantsResponse>;
                        granteeGrants(request: import("../cosmos/authz/v1beta1/query").QueryGranteeGrantsRequest): Promise<import("../cosmos/authz/v1beta1/query").QueryGranteeGrantsResponse>;
                    };
                };
                bank: {
                    v1beta1: {
                        balance(request: import("../cosmos/bank/v1beta1/query").QueryBalanceRequest): Promise<import("../cosmos/bank/v1beta1/query").QueryBalanceResponse>;
                        allBalances(request: import("../cosmos/bank/v1beta1/query").QueryAllBalancesRequest): Promise<import("../cosmos/bank/v1beta1/query").QueryAllBalancesResponse>;
                        spendableBalances(request: import("../cosmos/bank/v1beta1/query").QuerySpendableBalancesRequest): Promise<import("../cosmos/bank/v1beta1/query").QuerySpendableBalancesResponse>;
                        totalSupply(request?: import("../cosmos/bank/v1beta1/query").QueryTotalSupplyRequest): Promise<import("../cosmos/bank/v1beta1/query").QueryTotalSupplyResponse>;
                        supplyOf(request: import("../cosmos/bank/v1beta1/query").QuerySupplyOfRequest): Promise<import("../cosmos/bank/v1beta1/query").QuerySupplyOfResponse>;
                        params(request?: import("../cosmos/bank/v1beta1/query").QueryParamsRequest): Promise<import("../cosmos/bank/v1beta1/query").QueryParamsResponse>;
                        denomMetadata(request: import("../cosmos/bank/v1beta1/query").QueryDenomMetadataRequest): Promise<import("../cosmos/bank/v1beta1/query").QueryDenomMetadataResponse>;
                        denomsMetadata(request?: import("../cosmos/bank/v1beta1/query").QueryDenomsMetadataRequest): Promise<import("../cosmos/bank/v1beta1/query").QueryDenomsMetadataResponse>;
                    };
                };
                base: {
                    node: {
                        v1beta1: {
                            config(request?: import("../cosmos/base/node/v1beta1/query").ConfigRequest): Promise<import("../cosmos/base/node/v1beta1/query").ConfigResponse>;
                        };
                    };
                    tendermint: {
                        v1beta1: {
                            getNodeInfo(request?: import("../cosmos/base/tendermint/v1beta1/query").GetNodeInfoRequest): Promise<import("../cosmos/base/tendermint/v1beta1/query").GetNodeInfoResponse>;
                            getSyncing(request?: import("../cosmos/base/tendermint/v1beta1/query").GetSyncingRequest): Promise<import("../cosmos/base/tendermint/v1beta1/query").GetSyncingResponse>;
                            getLatestBlock(request?: import("../cosmos/base/tendermint/v1beta1/query").GetLatestBlockRequest): Promise<import("../cosmos/base/tendermint/v1beta1/query").GetLatestBlockResponse>;
                            getBlockByHeight(request: import("../cosmos/base/tendermint/v1beta1/query").GetBlockByHeightRequest): Promise<import("../cosmos/base/tendermint/v1beta1/query").GetBlockByHeightResponse>;
                            getLatestValidatorSet(request?: import("../cosmos/base/tendermint/v1beta1/query").GetLatestValidatorSetRequest): Promise<import("../cosmos/base/tendermint/v1beta1/query").GetLatestValidatorSetResponse>;
                            getValidatorSetByHeight(request: import("../cosmos/base/tendermint/v1beta1/query").GetValidatorSetByHeightRequest): Promise<import("../cosmos/base/tendermint/v1beta1/query").GetValidatorSetByHeightResponse>;
                        };
                    };
                };
                distribution: {
                    v1beta1: {
                        params(request?: import("../cosmos/distribution/v1beta1/query").QueryParamsRequest): Promise<import("../cosmos/distribution/v1beta1/query").QueryParamsResponse>;
                        validatorOutstandingRewards(request: import("../cosmos/distribution/v1beta1/query").QueryValidatorOutstandingRewardsRequest): Promise<import("../cosmos/distribution/v1beta1/query").QueryValidatorOutstandingRewardsResponse>;
                        validatorCommission(request: import("../cosmos/distribution/v1beta1/query").QueryValidatorCommissionRequest): Promise<import("../cosmos/distribution/v1beta1/query").QueryValidatorCommissionResponse>;
                        validatorSlashes(request: import("../cosmos/distribution/v1beta1/query").QueryValidatorSlashesRequest): Promise<import("../cosmos/distribution/v1beta1/query").QueryValidatorSlashesResponse>;
                        delegationRewards(request: import("../cosmos/distribution/v1beta1/query").QueryDelegationRewardsRequest): Promise<import("../cosmos/distribution/v1beta1/query").QueryDelegationRewardsResponse>;
                        delegationTotalRewards(request: import("../cosmos/distribution/v1beta1/query").QueryDelegationTotalRewardsRequest): Promise<import("../cosmos/distribution/v1beta1/query").QueryDelegationTotalRewardsResponse>;
                        delegatorValidators(request: import("../cosmos/distribution/v1beta1/query").QueryDelegatorValidatorsRequest): Promise<import("../cosmos/distribution/v1beta1/query").QueryDelegatorValidatorsResponse>;
                        delegatorWithdrawAddress(request: import("../cosmos/distribution/v1beta1/query").QueryDelegatorWithdrawAddressRequest): Promise<import("../cosmos/distribution/v1beta1/query").QueryDelegatorWithdrawAddressResponse>;
                        communityPool(request?: import("../cosmos/distribution/v1beta1/query").QueryCommunityPoolRequest): Promise<import("../cosmos/distribution/v1beta1/query").QueryCommunityPoolResponse>;
                        tokenizeShareRecordReward(request: import("../cosmos/distribution/v1beta1/query").QueryTokenizeShareRecordRewardRequest): Promise<import("../cosmos/distribution/v1beta1/query").QueryTokenizeShareRecordRewardResponse>;
                    };
                };
                evidence: {
                    v1beta1: {
                        evidence(request: import("../cosmos/evidence/v1beta1/query").QueryEvidenceRequest): Promise<import("../cosmos/evidence/v1beta1/query").QueryEvidenceResponse>;
                        allEvidence(request?: import("../cosmos/evidence/v1beta1/query").QueryAllEvidenceRequest): Promise<import("../cosmos/evidence/v1beta1/query").QueryAllEvidenceResponse>;
                    };
                };
                feegrant: {
                    v1beta1: {
                        allowance(request: import("../cosmos/feegrant/v1beta1/query").QueryAllowanceRequest): Promise<import("../cosmos/feegrant/v1beta1/query").QueryAllowanceResponse>;
                        allowances(request: import("../cosmos/feegrant/v1beta1/query").QueryAllowancesRequest): Promise<import("../cosmos/feegrant/v1beta1/query").QueryAllowancesResponse>;
                        allowancesByGranter(request: import("../cosmos/feegrant/v1beta1/query").QueryAllowancesByGranterRequest): Promise<import("../cosmos/feegrant/v1beta1/query").QueryAllowancesByGranterResponse>;
                    };
                };
                gov: {
                    v1beta1: {
                        proposal(request: import("../cosmos/gov/v1beta1/query").QueryProposalRequest): Promise<import("../cosmos/gov/v1beta1/query").QueryProposalResponse>;
                        proposals(request: import("../cosmos/gov/v1beta1/query").QueryProposalsRequest): Promise<import("../cosmos/gov/v1beta1/query").QueryProposalsResponse>;
                        vote(request: import("../cosmos/gov/v1beta1/query").QueryVoteRequest): Promise<import("../cosmos/gov/v1beta1/query").QueryVoteResponse>;
                        votes(request: import("../cosmos/gov/v1beta1/query").QueryVotesRequest): Promise<import("../cosmos/gov/v1beta1/query").QueryVotesResponse>;
                        params(request: import("../cosmos/gov/v1beta1/query").QueryParamsRequest): Promise<import("../cosmos/gov/v1beta1/query").QueryParamsResponse>;
                        deposit(request: import("../cosmos/gov/v1beta1/query").QueryDepositRequest): Promise<import("../cosmos/gov/v1beta1/query").QueryDepositResponse>;
                        deposits(request: import("../cosmos/gov/v1beta1/query").QueryDepositsRequest): Promise<import("../cosmos/gov/v1beta1/query").QueryDepositsResponse>;
                        tallyResult(request: import("../cosmos/gov/v1beta1/query").QueryTallyResultRequest): Promise<import("../cosmos/gov/v1beta1/query").QueryTallyResultResponse>;
                    };
                };
                mint: {
                    v1beta1: {
                        params(request?: import("../cosmos/mint/v1beta1/query").QueryParamsRequest): Promise<import("../cosmos/mint/v1beta1/query").QueryParamsResponse>;
                        inflation(request?: import("../cosmos/mint/v1beta1/query").QueryInflationRequest): Promise<import("../cosmos/mint/v1beta1/query").QueryInflationResponse>;
                        annualProvisions(request?: import("../cosmos/mint/v1beta1/query").QueryAnnualProvisionsRequest): Promise<import("../cosmos/mint/v1beta1/query").QueryAnnualProvisionsResponse>;
                    };
                };
                params: {
                    v1beta1: {
                        params(request: import("../cosmos/params/v1beta1/query").QueryParamsRequest): Promise<import("../cosmos/params/v1beta1/query").QueryParamsResponse>;
                    };
                };
                slashing: {
                    v1beta1: {
                        params(request?: import("../cosmos/slashing/v1beta1/query").QueryParamsRequest): Promise<import("../cosmos/slashing/v1beta1/query").QueryParamsResponse>;
                        signingInfo(request: import("../cosmos/slashing/v1beta1/query").QuerySigningInfoRequest): Promise<import("../cosmos/slashing/v1beta1/query").QuerySigningInfoResponse>;
                        signingInfos(request?: import("../cosmos/slashing/v1beta1/query").QuerySigningInfosRequest): Promise<import("../cosmos/slashing/v1beta1/query").QuerySigningInfosResponse>;
                    };
                };
                staking: {
                    v1beta1: {
                        validators(request: import("../cosmos/staking/v1beta1/query").QueryValidatorsRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryValidatorsResponse>;
                        validator(request: import("../cosmos/staking/v1beta1/query").QueryValidatorRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryValidatorResponse>;
                        validatorDelegations(request: import("../cosmos/staking/v1beta1/query").QueryValidatorDelegationsRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryValidatorDelegationsResponse>;
                        validatorUnbondingDelegations(request: import("../cosmos/staking/v1beta1/query").QueryValidatorUnbondingDelegationsRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryValidatorUnbondingDelegationsResponse>;
                        delegation(request: import("../cosmos/staking/v1beta1/query").QueryDelegationRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryDelegationResponse>;
                        unbondingDelegation(request: import("../cosmos/staking/v1beta1/query").QueryUnbondingDelegationRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryUnbondingDelegationResponse>;
                        delegatorDelegations(request: import("../cosmos/staking/v1beta1/query").QueryDelegatorDelegationsRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryDelegatorDelegationsResponse>;
                        delegatorUnbondingDelegations(request: import("../cosmos/staking/v1beta1/query").QueryDelegatorUnbondingDelegationsRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryDelegatorUnbondingDelegationsResponse>;
                        redelegations(request: import("../cosmos/staking/v1beta1/query").QueryRedelegationsRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryRedelegationsResponse>;
                        delegatorValidators(request: import("../cosmos/staking/v1beta1/query").QueryDelegatorValidatorsRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryDelegatorValidatorsResponse>;
                        delegatorValidator(request: import("../cosmos/staking/v1beta1/query").QueryDelegatorValidatorRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryDelegatorValidatorResponse>;
                        historicalInfo(request: import("../cosmos/staking/v1beta1/query").QueryHistoricalInfoRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryHistoricalInfoResponse>;
                        pool(request?: import("../cosmos/staking/v1beta1/query").QueryPoolRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryPoolResponse>;
                        params(request?: import("../cosmos/staking/v1beta1/query").QueryParamsRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryParamsResponse>;
                        tokenizeShareRecordById(request: import("../cosmos/staking/v1beta1/query").QueryTokenizeShareRecordByIdRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryTokenizeShareRecordByIdResponse>;
                        tokenizeShareRecordByDenom(request: import("../cosmos/staking/v1beta1/query").QueryTokenizeShareRecordByDenomRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryTokenizeShareRecordByDenomResponse>;
                        tokenizeShareRecordsOwned(request: import("../cosmos/staking/v1beta1/query").QueryTokenizeShareRecordsOwnedRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryTokenizeShareRecordsOwnedResponse>;
                        allTokenizeShareRecords(request?: import("../cosmos/staking/v1beta1/query").QueryAllTokenizeShareRecordsRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryAllTokenizeShareRecordsResponse>;
                        lastTokenizeShareRecordId(request?: import("../cosmos/staking/v1beta1/query").QueryLastTokenizeShareRecordIdRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryLastTokenizeShareRecordIdResponse>;
                        totalTokenizeSharedAssets(request?: import("../cosmos/staking/v1beta1/query").QueryTotalTokenizeSharedAssetsRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryTotalTokenizeSharedAssetsResponse>;
                        totalLiquidStaked(request?: import("../cosmos/staking/v1beta1/query").QueryTotalLiquidStaked): Promise<import("../cosmos/staking/v1beta1/query").QueryTotalLiquidStakedResponse>;
                        tokenizeShareLockInfo(request: import("../cosmos/staking/v1beta1/query").QueryTokenizeShareLockInfo): Promise<import("../cosmos/staking/v1beta1/query").QueryTokenizeShareLockInfoResponse>;
                    };
                };
                tx: {
                    v1beta1: {
                        simulate(request: import("../cosmos/tx/v1beta1/service").SimulateRequest): Promise<import("../cosmos/tx/v1beta1/service").SimulateResponse>;
                        getTx(request: import("../cosmos/tx/v1beta1/service").GetTxRequest): Promise<import("../cosmos/tx/v1beta1/service").GetTxResponse>;
                        broadcastTx(request: import("../cosmos/tx/v1beta1/service").BroadcastTxRequest): Promise<import("../cosmos/tx/v1beta1/service").BroadcastTxResponse>;
                        getTxsEvent(request: import("../cosmos/tx/v1beta1/service").GetTxsEventRequest): Promise<import("../cosmos/tx/v1beta1/service").GetTxsEventResponse>;
                        getBlockWithTxs(request: import("../cosmos/tx/v1beta1/service").GetBlockWithTxsRequest): Promise<import("../cosmos/tx/v1beta1/service").GetBlockWithTxsResponse>;
                    };
                };
                upgrade: {
                    v1beta1: {
                        currentPlan(request?: import("../cosmos/upgrade/v1beta1/query").QueryCurrentPlanRequest): Promise<import("../cosmos/upgrade/v1beta1/query").QueryCurrentPlanResponse>;
                        appliedPlan(request: import("../cosmos/upgrade/v1beta1/query").QueryAppliedPlanRequest): Promise<import("../cosmos/upgrade/v1beta1/query").QueryAppliedPlanResponse>;
                        upgradedConsensusState(request: import("../cosmos/upgrade/v1beta1/query").QueryUpgradedConsensusStateRequest): Promise<import("../cosmos/upgrade/v1beta1/query").QueryUpgradedConsensusStateResponse>;
                        moduleVersions(request: import("../cosmos/upgrade/v1beta1/query").QueryModuleVersionsRequest): Promise<import("../cosmos/upgrade/v1beta1/query").QueryModuleVersionsResponse>;
                    };
                };
            };
            stride: {
                airdrop: {
                    airdrop(request: _95.QueryAirdropRequest): Promise<_95.QueryAirdropResponse>;
                    allAirdrops(request?: _95.QueryAllAirdropsRequest): Promise<_95.QueryAllAirdropsResponse>;
                    userAllocation(request: _95.QueryUserAllocationRequest): Promise<_95.QueryUserAllocationResponse>;
                    userAllocations(request: _95.QueryUserAllocationsRequest): Promise<_95.QueryUserAllocationsResponse>;
                    allAllocations(request: _95.QueryAllAllocationsRequest): Promise<_95.QueryAllAllocationsResponse>;
                    userSummary(request: _95.QueryUserSummaryRequest): Promise<_95.QueryUserSummaryResponse>;
                };
                autopilot: {
                    params(request?: _99.QueryParamsRequest): Promise<_99.QueryParamsResponse>;
                };
                claim: {
                    distributorAccountBalance(request: _103.QueryDistributorAccountBalanceRequest): Promise<_103.QueryDistributorAccountBalanceResponse>;
                    params(request?: _103.QueryParamsRequest): Promise<_103.QueryParamsResponse>;
                    claimRecord(request: _103.QueryClaimRecordRequest): Promise<_103.QueryClaimRecordResponse>;
                    claimableForAction(request: _103.QueryClaimableForActionRequest): Promise<_103.QueryClaimableForActionResponse>;
                    totalClaimable(request: _103.QueryTotalClaimableRequest): Promise<_103.QueryTotalClaimableResponse>;
                    userVestings(request: _103.QueryUserVestingsRequest): Promise<_103.QueryUserVestingsResponse>;
                    claimStatus(request: _103.QueryClaimStatusRequest): Promise<_103.QueryClaimStatusResponse>;
                    claimMetadata(request?: _103.QueryClaimMetadataRequest): Promise<_103.QueryClaimMetadataResponse>;
                };
                epochs: {
                    epochInfos(request?: _106.QueryEpochsInfoRequest): Promise<_106.QueryEpochsInfoResponse>;
                    currentEpoch(request: _106.QueryCurrentEpochRequest): Promise<_106.QueryCurrentEpochResponse>;
                    epochInfo(request: _106.QueryEpochInfoRequest): Promise<_106.QueryEpochInfoResponse>;
                };
                icacallbacks: {
                    params(request?: _111.QueryParamsRequest): Promise<_111.QueryParamsResponse>;
                    callbackData(request: _111.QueryGetCallbackDataRequest): Promise<_111.QueryGetCallbackDataResponse>;
                    callbackDataAll(request?: _111.QueryAllCallbackDataRequest): Promise<_111.QueryAllCallbackDataResponse>;
                };
                icaoracle: {
                    oracle(request: _117.QueryOracleRequest): Promise<_117.QueryOracleResponse>;
                    allOracles(request?: _117.QueryAllOraclesRequest): Promise<_117.QueryAllOraclesResponse>;
                    activeOracles(request: _117.QueryActiveOraclesRequest): Promise<_117.QueryActiveOraclesResponse>;
                    metrics(request: _117.QueryMetricsRequest): Promise<_117.QueryMetricsResponse>;
                };
                mint: {
                    v1beta1: {
                        params(request?: _124.QueryParamsRequest): Promise<_124.QueryParamsResponse>;
                        epochProvisions(request?: _124.QueryEpochProvisionsRequest): Promise<_124.QueryEpochProvisionsResponse>;
                    };
                };
                records: {
                    params(request?: _128.QueryParamsRequest): Promise<_128.QueryParamsResponse>;
                    userRedemptionRecord(request: _128.QueryGetUserRedemptionRecordRequest): Promise<_128.QueryGetUserRedemptionRecordResponse>;
                    userRedemptionRecordAll(request?: _128.QueryAllUserRedemptionRecordRequest): Promise<_128.QueryAllUserRedemptionRecordResponse>;
                    userRedemptionRecordForUser(request: _128.QueryAllUserRedemptionRecordForUserRequest): Promise<_128.QueryAllUserRedemptionRecordForUserResponse>;
                    epochUnbondingRecord(request: _128.QueryGetEpochUnbondingRecordRequest): Promise<_128.QueryGetEpochUnbondingRecordResponse>;
                    epochUnbondingRecordAll(request?: _128.QueryAllEpochUnbondingRecordRequest): Promise<_128.QueryAllEpochUnbondingRecordResponse>;
                    depositRecord(request: _128.QueryGetDepositRecordRequest): Promise<_128.QueryGetDepositRecordResponse>;
                    depositRecordAll(request?: _128.QueryAllDepositRecordRequest): Promise<_128.QueryAllDepositRecordResponse>;
                    depositRecordByHost(request: _128.QueryDepositRecordByHostRequest): Promise<_128.QueryDepositRecordByHostResponse>;
                    lSMDeposit(request: _128.QueryLSMDepositRequest): Promise<_128.QueryLSMDepositResponse>;
                    lSMDeposits(request: _128.QueryLSMDepositsRequest): Promise<_128.QueryLSMDepositsResponse>;
                };
                stakedym: {
                    hostZone(request?: _131.QueryHostZoneRequest): Promise<_131.QueryHostZoneResponse>;
                    delegationRecords(request: _131.QueryDelegationRecordsRequest): Promise<_131.QueryDelegationRecordsResponse>;
                    unbondingRecords(request: _131.QueryUnbondingRecordsRequest): Promise<_131.QueryUnbondingRecordsResponse>;
                    redemptionRecord(request: _131.QueryRedemptionRecordRequest): Promise<_131.QueryRedemptionRecordResponse>;
                    redemptionRecords(request: _131.QueryRedemptionRecordsRequest): Promise<_131.QueryRedemptionRecordsResponse>;
                    slashRecords(request?: _131.QuerySlashRecordsRequest): Promise<_131.QuerySlashRecordsResponse>;
                };
                stakeibc: {
                    params(request?: _143.QueryParamsRequest): Promise<_143.QueryParamsResponse>;
                    validators(request: _143.QueryGetValidatorsRequest): Promise<_143.QueryGetValidatorsResponse>;
                    hostZone(request: _143.QueryGetHostZoneRequest): Promise<_143.QueryGetHostZoneResponse>;
                    hostZoneAll(request?: _143.QueryAllHostZoneRequest): Promise<_143.QueryAllHostZoneResponse>;
                    moduleAddress(request: _143.QueryModuleAddressRequest): Promise<_143.QueryModuleAddressResponse>;
                    interchainAccountFromAddress(request: _143.QueryInterchainAccountFromAddressRequest): Promise<_143.QueryInterchainAccountFromAddressResponse>;
                    epochTracker(request: _143.QueryGetEpochTrackerRequest): Promise<_143.QueryGetEpochTrackerResponse>;
                    epochTrackerAll(request?: _143.QueryAllEpochTrackerRequest): Promise<_143.QueryAllEpochTrackerResponse>;
                    nextPacketSequence(request: _143.QueryGetNextPacketSequenceRequest): Promise<_143.QueryGetNextPacketSequenceResponse>;
                    addressUnbondings(request: _143.QueryAddressUnbondings): Promise<_143.QueryAddressUnbondingsResponse>;
                    allTradeRoutes(request?: _143.QueryAllTradeRoutes): Promise<_143.QueryAllTradeRoutesResponse>;
                };
                staketia: {
                    hostZone(request?: _148.QueryHostZoneRequest): Promise<_148.QueryHostZoneResponse>;
                    delegationRecords(request: _148.QueryDelegationRecordsRequest): Promise<_148.QueryDelegationRecordsResponse>;
                    unbondingRecords(request: _148.QueryUnbondingRecordsRequest): Promise<_148.QueryUnbondingRecordsResponse>;
                    redemptionRecord(request: _148.QueryRedemptionRecordRequest): Promise<_148.QueryRedemptionRecordResponse>;
                    redemptionRecords(request: _148.QueryRedemptionRecordsRequest): Promise<_148.QueryRedemptionRecordsResponse>;
                    slashRecords(request?: _148.QuerySlashRecordsRequest): Promise<_148.QuerySlashRecordsResponse>;
                };
            };
        }>;
        createLCDClient: ({ restEndpoint }: {
            restEndpoint: string;
        }) => Promise<{
            cosmos: {
                auth: {
                    v1beta1: import("../cosmos/auth/v1beta1/query.lcd").LCDQueryClient;
                };
                authz: {
                    v1beta1: import("../cosmos/authz/v1beta1/query.lcd").LCDQueryClient;
                };
                bank: {
                    v1beta1: import("../cosmos/bank/v1beta1/query.lcd").LCDQueryClient;
                };
                base: {
                    node: {
                        v1beta1: import("../cosmos/base/node/v1beta1/query.lcd").LCDQueryClient;
                    };
                    tendermint: {
                        v1beta1: import("../cosmos/base/tendermint/v1beta1/query.lcd").LCDQueryClient;
                    };
                };
                distribution: {
                    v1beta1: import("../cosmos/distribution/v1beta1/query.lcd").LCDQueryClient;
                };
                evidence: {
                    v1beta1: import("../cosmos/evidence/v1beta1/query.lcd").LCDQueryClient;
                };
                feegrant: {
                    v1beta1: import("../cosmos/feegrant/v1beta1/query.lcd").LCDQueryClient;
                };
                gov: {
                    v1beta1: import("../cosmos/gov/v1beta1/query.lcd").LCDQueryClient;
                };
                mint: {
                    v1beta1: import("../cosmos/mint/v1beta1/query.lcd").LCDQueryClient;
                };
                params: {
                    v1beta1: import("../cosmos/params/v1beta1/query.lcd").LCDQueryClient;
                };
                slashing: {
                    v1beta1: import("../cosmos/slashing/v1beta1/query.lcd").LCDQueryClient;
                };
                staking: {
                    v1beta1: import("../cosmos/staking/v1beta1/query.lcd").LCDQueryClient;
                };
                tx: {
                    v1beta1: import("../cosmos/tx/v1beta1/service.lcd").LCDQueryClient;
                };
                upgrade: {
                    v1beta1: import("../cosmos/upgrade/v1beta1/query.lcd").LCDQueryClient;
                };
            };
            stride: {
                airdrop: _240.LCDQueryClient;
                autopilot: _241.LCDQueryClient;
                claim: _242.LCDQueryClient;
                epochs: _243.LCDQueryClient;
                icacallbacks: _244.LCDQueryClient;
                icaoracle: _245.LCDQueryClient;
                mint: {
                    v1beta1: _246.LCDQueryClient;
                };
                records: _247.LCDQueryClient;
                stakedym: _248.LCDQueryClient;
                stakeibc: _249.LCDQueryClient;
                staketia: _250.LCDQueryClient;
            };
        }>;
    };
}
